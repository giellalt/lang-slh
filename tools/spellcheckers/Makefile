# Makefile.in generated by automake 1.16.5 from Makefile.am.
# tools/spellcheckers/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2021 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.



#########################################
# BEGIN: Local processing
#
# Target template:
#
# analyser-speller-gt-norm.%: analyser-speller-gt-norm.tmp.%
#	build rules

### BEGIN: Local build rules: *.hfst: *.tmp.hfst ###

####### HFST build rules: ########

###########################################
########## XFScript build rules. ##########
###########################################

# *.gt.* designates the tagset being used.
# At the end of the makefile, there is support for automatic compilation of
# other tagsets, given that the proper tagset relabeling files are defined,
# and that the target files are defined as part of the 'all' target.
#
# Filenames are built as follows:
# basictype-application-tagset-normativity[-dialect].fsttype
#
# 'application' is not specified for the regular/default morphological
# analysis/generation.
#
# Examples:
# analyser-oahpa-gt-desc.hfst
# generator-apertium-apertium-norm_single.hfst
# analyser-gt-desc.xfst
#
# Full details regarding transducer filenames can be found at:
#
# https://giellalt.uit.no/infra/infraremake/TransducerNamesInTheNewInfra.html

#### Tailored silent output text: ####

#### HFST tools
# Tools not yet covered by this file:
#
# hfst-determinize
# hfst-fst2strings
# hfst-info
# hfst-minus
# hfst-multiply
# hfst-pair-test
# hfst-pmatch
# hfst-push-weights
# hfst-remove-epsilons
# hfst-shuffle
# hfst-subtract
# hfst-summarize
# hfst-tokenize


am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/giella-slh
pkgincludedir = $(includedir)/giella-slh
pkglibdir = $(libdir)/giella-slh
pkglibexecdir = $(libexecdir)/giella-slh
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = aarch64-apple-darwin23.4.0
host_triplet = aarch64-apple-darwin23.4.0

####### Automake targets: ########
### END: AREA filter conditional:

####### Automake targets: ########

####### Automake targets: ########
#am__append_1 = analyser-$(GT_COMMON_SPELLER_NAME).hfst \
#	generator-$(GT_COMMON_SPELLER_NAME).hfst \
#	generator-fstspeller-gt-norm.hfst \
#	analyser-fstspeller-gt-norm.hfst \
#	.generated/generator-desktopspeller-gt-norm.hfst \
#	.generated/analyser-desktopspeller-gt-norm.hfst
#GT_ERRMODELS+=errmodel.edit-distance-1.hfst
#am__append_2 = errmodel.default.hfst

####### Automake targets: ########
#am__append_3 = generator-mobilespeller-gt-norm.hfst \
#	analyser-mobilespeller-gt-norm.hfst
#MOB_GIELLA_ERRMODELS+=errmodel.edit-distance-1.hfst

# Only build speller if it is enabled (default=yes)
##am__append_4 = errmodel.default.mobile.hfst
##am__append_5 = errmodel.default.predict.hfst
subdir = tools/spellcheckers
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/ax_check_gnu_make.m4 \
	$(top_srcdir)/m4/ax_compare_version.m4 \
	$(top_srcdir)/m4/ax_python_module.m4 \
	$(top_srcdir)/m4/giella-config-files.m4 \
	$(top_srcdir)/m4/giella-macros.m4 $(top_srcdir)/m4/hfst.m4 \
	$(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES = index.xml index.mobile.xml
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
am__vpath_adj = case $$p in \
    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
    *) f=$$p;; \
  esac;
am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
am__install_max = 40
am__nobase_strip_setup = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
am__nobase_strip = \
  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
am__nobase_list = $(am__nobase_strip_setup); \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
am__uninstall_files_from_dir = { \
  test -z "$$files" \
    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
         $(am__cd) "$$dir" && rm -f $$files; }; \
  }
am__installdirs = "$(DESTDIR)$(mobilespellerdir)" \
	"$(DESTDIR)$(voikkosharedir)"
DATA = $(mobilespeller_DATA) $(noinst_DATA) $(voikkoshare_DATA)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir distdir-am
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in \
	$(srcdir)/Makefile.mod-desktop-hfst.am \
	$(srcdir)/Makefile.mod-desktop.am \
	$(srcdir)/Makefile.mod-fstbased.am \
	$(srcdir)/Makefile.mod-mobile-hfst.am \
	$(srcdir)/Makefile.mod-mobile.am \
	$(srcdir)/Makefile.mod-spellcheckers.am \
	$(srcdir)/index.mobile.xml.in $(srcdir)/index.xml.in \
	$(top_srcdir)/../giella-core/am-shared/dot-generated-dir.am \
	$(top_srcdir)/../giella-core/am-shared/hfst-format-include.am \
	$(top_srcdir)/../giella-core/am-shared/regex-include.am \
	$(top_srcdir)/../giella-core/am-shared/silent_build-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_orth-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_ws-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_area-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop_weights-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-hfst-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile_weights-dir-include.am \
	$(top_srcdir)/../giella-core/am-shared/xfscript-include.am
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = ${SHELL} '/Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/missing' aclocal-1.16
ALT_ORTHS = 
ALT_WSS = 
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 0
AREAS = 
AUTOCONF = ${SHELL} '/Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/missing' autoconf
AUTOHEADER = ${SHELL} '/Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/missing' autoheader
AUTOMAKE = ${SHELL} '/Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/missing' automake-1.16
AWK = gawk
BC = /usr/bin/bc
CG3_CFLAGS = -I/usr/local/include/
CG3_LIBS = -L/usr/local/lib -lcg3
CGFLOOKUP = /usr/local/bin/cgflookup
CG_MWESPLIT = /usr/local/bin/cg-mwesplit
CG_RELABEL = /usr/local/bin/cg-relabel
CSCOPE = cscope
CTAGS = ctags
CYGPATH_W = echo
CYGWINJAVAPATH = echo
DEFAULT_ANALYSERS = yes
DEFAULT_CUSTOM_FSTS = yes
DEFAULT_FOMA = no
DEFAULT_GENERATORS = yes
DEFAULT_HFST = yes
DEFAULT_HFST_BACKEND = foma
DEFAULT_HYPERMIN = no
DEFAULT_ORTH = 
DEFAULT_REVERCI = yes
DEFAULT_SPELLER_MINIMISATION = no
DEFAULT_WS = Latn
DEFAULT_XFST = no
DEFS = -DPACKAGE_NAME=\"Giella\ slh\" -DPACKAGE_TARNAME=\"giella-slh\" -DPACKAGE_VERSION=\"0.1.0\" -DPACKAGE_STRING=\"Giella\ slh\ 0.1.0\" -DPACKAGE_BUGREPORT=\"feedback@divvun.no\" -DPACKAGE_URL=\"http://divvun.no\" -DPACKAGE=\"giella-slh\" -DVERSION=\"0.1.0\"
DIALECTS = 
DIFFTOOL = /usr/bin/opendiff
DIVVUN_ACCURACY = 
DIVVUN_CHECKER = /usr/local/bin/divvun-checker
DIVVUN_VALIDATE_SUGGEST = /usr/local/bin/divvun-validate-suggest
ECHO_C = \c
ECHO_N = 
ECHO_T = 
ETAGS = etags
FLOOKUP = /usr/local/bin/flookup
FOMA = /usr/local/bin/foma
FORREST = 
GAWK = /opt/homebrew/bin/gawk
GIELLA_CORE = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/./../giella-core
GIELLA_CORE_VERSION = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/./../giella-core/scripts/gt-version.sh
GLANG = slh
GLANG2 = slh
GLANGUAGE = Southern Puget Sound Salish
GRAMCHECKVERSION = 0.1.0
GTCORE = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/./../giella-core
GTCORESH = /Users/jackrueter/Dropbox/Github/giellalt/giella-core/scripts/gt-core.sh
GTLANG = slh
GTLANG2 = slh
GTLANGUAGE = Southern Puget Sound Salish
GZIP = /usr/bin/gzip
HFST_COMPOSE = /usr/local/bin/hfst-compose
HFST_COMPOSE_INTERSECT = /usr/local/bin/hfst-compose-intersect
HFST_CONCATENATE = /usr/local/bin/hfst-concatenate
HFST_CONJUNCT = /usr/local/bin/hfst-conjunct
HFST_DETERMINIZE = /usr/local/bin/hfst-determinize
HFST_DISJUNCT = /usr/local/bin/hfst-disjunct
HFST_FOMA = false
HFST_FORMAT_NAME = foma
HFST_FST2FST = /usr/local/bin/hfst-fst2fst
HFST_FST2STRINGS = /usr/local/bin/hfst-fst2strings
HFST_FST2TXT = /usr/local/bin/hfst-fst2txt
HFST_INFO = /usr/local/bin/hfst-info
HFST_INTERSECT = /usr/local/bin/hfst-intersect
HFST_INVERT = /usr/local/bin/hfst-invert
HFST_LEXC = /usr/local/bin/hfst-lexc
HFST_LOOKUP = /usr/local/bin/hfst-lookup
HFST_MINIMIZE = /usr/local/bin/hfst-minimize
HFST_MINIMIZE_SPELLER = /usr/local/bin/hfst-remove-epsilons $(HFST_FLAGS) $(MORE_VERBOSITY) 
HFST_MINUS = /usr/local/bin/hfst-minus
HFST_MULTIPLY = /usr/local/bin/hfst-multiply
HFST_NAME = /usr/local/bin/hfst-name
HFST_OPTIMIZED_LOOKUP = /usr/local/bin/hfst-optimized-lookup
HFST_OSPELL = /usr/local/bin/hfst-ospell
HFST_PAIR_TEST = /usr/local/bin/hfst-pair-test
HFST_PMATCH2FST = /usr/local/bin/hfst-pmatch2fst
HFST_PROC = /usr/local/bin/hfst-proc
HFST_PROJECT = /usr/local/bin/hfst-project
HFST_PRUNE_ALPHABET = /usr/local/bin/hfst-prune-alphabet
HFST_PUSH_WEIGHTS = /usr/local/bin/hfst-push-weights
HFST_REGEXP2FST = /usr/local/bin/hfst-regexp2fst
HFST_REMOVE_EPSILONS = /usr/local/bin/hfst-remove-epsilons
HFST_REPEAT = /usr/local/bin/hfst-repeat
HFST_REVERSE = /usr/local/bin/hfst-reverse
HFST_REWEIGHT = /usr/local/bin/hfst-reweight
HFST_SPLIT = /usr/local/bin/hfst-split
HFST_STRINGS2FST = /usr/local/bin/hfst-strings2fst
HFST_SUBSTITUTE = /usr/local/bin/hfst-substitute
HFST_SUBTRACT = /usr/local/bin/hfst-subtract
HFST_SUMMARIZE = /usr/local/bin/hfst-summarize
HFST_TOKENISE = /usr/local/bin/hfst-tokenize
HFST_TWOLC = /usr/local/bin/hfst-twolc
HFST_TXT2FST = /usr/local/bin/hfst-txt2fst
HFST_XFST = /usr/local/bin/hfst-xfst
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
JV = /usr/bin/java
LEXC = false
LEXREF_IN_XFSCRIPT = 
LIBOBJS = 
LIBS = 
LOOKUP = false
LTLIBOBJS = 
MAKEINFO = ${SHELL} '/Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/missing' makeinfo
MKDIR_P = mkdir -p
NO_PHONOLOGY = 
NPM = 
ONMT_BUILD_VOCAB = 
ONMT_TRAIN = 
PACKAGE = giella-slh
PACKAGE_BUGREPORT = feedback@divvun.no
PACKAGE_NAME = Giella slh
PACKAGE_STRING = Giella slh 0.1.0
PACKAGE_TARNAME = giella-slh
PACKAGE_URL = http://divvun.no
PACKAGE_VERSION = 0.1.0
PATGEN = false
PATH_SEPARATOR = :
PERL = /opt/homebrew/bin/perl
PKG_CONFIG = /opt/homebrew/bin/pkg-config
PKG_CONFIG_LIBDIR = 
PKG_CONFIG_PATH = /usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:/opt/homebrew/opt/libxml2/lib/pkgconfig:/opt/homebrew/opt/icu4c/lib/pkgconfig:
PRINTF = /usr/bin/printf
PYTHON = /Library/Frameworks/Python.framework/Versions/3.8/bin/python3
PYTHON_EXEC_PREFIX = ${exec_prefix}
PYTHON_PLATFORM = darwin
PYTHON_PREFIX = ${prefix}
PYTHON_VERSION = 3.8
R = 
RSYNC = /usr/bin/rsync
SAXON = false
SAXONJAR = /Users/jackrueter/lib/saxon9he.jar
SED = /usr/bin/sed
SEE = 
SET_MAKE = 
SHELL = /bin/sh
SPELLERVERSION = 0.1.0
SPELLER_DESC_ENG = A spellchecker for Southern Puget Sound Salish, made by members of the language community, and by the Divvun and Giellatekno groups at UiT The Arctic University of Norway
SPELLER_DESC_NATIVE = TRANSLATE: A spellchecker for Southern Puget Sound Salish, made by members of the language community, and by the Divvun and Giellatekno groups at UiT The Arctic University of Norway
SPELLER_NAME_ENG = Southern Puget Sound Salish spellchecker
SPELLER_NAME_NATIVE = Autonym spellchecker
STRIP = 
TAR = /usr/bin/tar
TWOLC = false
UCONV = /opt/homebrew/opt/icu4c/bin/uconv
VERSION = 0.1.0
VISLCG3 = /usr/local/bin/vislcg3
VISLCG3_COMP = /usr/local/bin/cg-comp
VOIKKOGC = false
VOIKKOHYPHENATE = false
VOIKKOSPELL = false
VOIKKOVFSTC = false
WGET = /opt/homebrew/bin/wget
XFST = false
XZ = /opt/homebrew/bin/xz
ZIP = /usr/bin/zip
abs_builddir = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/tools/spellcheckers
abs_srcdir = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/tools/spellcheckers
abs_top_builddir = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh
abs_top_srcdir = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh
am__leading_dot = .
am__tar = tar --format=posix -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = aarch64-apple-darwin23.4.0
build_alias = 
build_cpu = aarch64
build_os = darwin23.4.0
build_vendor = apple
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
gt_SHARED_common = /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/./../shared-mul
host = aarch64-apple-darwin23.4.0
host_alias = 
host_cpu = aarch64
host_os = darwin23.4.0
host_vendor = apple
htmldir = ${docdir}
ifGNUmake = 
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /Users/jackrueter/Dropbox/Github/giellalt/lang-slh/build-aux/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
pkgpyexecdir = ${pyexecdir}/giella-slh
pkgpythondir = ${pythondir}/giella-slh
prefix = /usr/local
program_transform_name = s,x,x,
psdir = ${docdir}
pyexecdir = ${PYTHON_EXEC_PREFIX}/lib/python3.8/site-packages
pythondir = ${PYTHON_PREFIX}/lib/python3.8/site-packages
runstatedir = ${localstatedir}/run
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target_alias = 
top_build_prefix = ../../
top_builddir = ../..
top_srcdir = ../..

# Subdirs in build order:
SUBDIRS = filters weights neural .

# Name of speller corpus sans suffix:
CORPUSNAME = spellercorpus

# Specify whether to use corpus weights for frequency ranking of suggestions.
# Make sure you test the suggestion quality both before and after changing this
# setting.
ENABLE_CORPUS_WEIGHTS = no

# TSV file defining weights per tag (in the weights/ dir):
TAGWEIGHTS = tags.reweight

# Number of lines (= word forms) in the sort-uniqued corpus. If empty the whole
# corpus will be used. Too large a corpus can make the acceptor fst unneccessary
# big without improving the suggestion quality in a noticable way. A starting
# point could be to only include word forms occurring at least twice. Try
# different values to find the best compromise between fst size and suggestion
# quality. Look at the file:
# tools/spellcheckers/fstbased/desktop/spellercorpus.uniq.txt
# and look for a relevant cut-off line, typically somewhere in the two occurence
# section.
CORPUS_SIZE = 

# This is the default weight for all editing operations in the error model:
DEFAULT_WEIGHT = 10

# Whether to use swaps - ..ab.. -> ..ba.. in one single operation.
# NB! Beware that this increases the size of the errormodel by ~ 3 * S^2, where
# S is the size of the alphabet. Ie by A LOT.
# If you want to enable swaps, consider using an edit distance of only 1, or
# better yet, dot NOT include UPPERCASE LETTERS in the error model alphabet.
#
# Possible values are 'yes' or 'no'
USE_SWAPS = no

# Edit distanse for the Levenshtein error model:
EDIT_DISTANCE = 2

# Define whether we allow changes to the initial letter(s) in the error model,
# possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
# NB!!! Setting this to anything but 'no' will greatly increase the size and
# search space of the error model, and thus make it much, much slower. Make sure
# you TEST the resulting error model properly and thoroughly, both for speed
# and suggestion quality.
INITIAL_EDITS = no

# Variable to define whether to enable edits of longer strings (as opposed to
# single letters). Possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
STRING_EDITS = txt
# Variable to specify the edit distance for the regex
# version of the strings file. The total edit distance for those operations is
# this value multiplied with the value of the EDIT_DISTANCE variable.
STRING_REGEX_EDIT_DISTANCE = 2

# Variable to define whether to enable edits of word-final strings (as opposed
# to single letters). Possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
FINAL_STRING_EDITS = no

# Variable to define whether to enable whole-word replacements. Possible values:
# - yes
# - no
WORD_REPLACEMENTS = no

# Name of speller corpus sans suffix:
MOBILE_CORPUSNAME = spellercorpus

# Specify whether to use corpus weights for frequency ranking of suggestions.
# Make sure you test the suggestion quality both before and after changing this
# setting.
ENABLE_MOB_CORPUS_WEIGHTS = no

# TSV file defining weights per tag (in the weights/ dir):
MOB_TAGWEIGHTS = tags.reweight

# Number of lines (= word forms) in the sort-uniqued corpus. If empty the whole
# corpus will be used. Too large a corpus can make the acceptor fst unneccessary
# big without improving the suggestion quality in a noticable way. A starting
# point could be to only include word forms occurring at least twice. Try
# different values to find the best compromise between fst size and suggestion
# quality.
MOB_CORPUS_SIZE = 

# This is the default weight for all editing operations in the error model:
MOB_DEFAULT_WEIGHT = 10

# Whether to use swaps - ..ab.. -> ..ba.. in one single operation.
# NB! Beware that this increases the size of the errormodel by ~ 3 * S^2, where
# S is the size of the alphabet. Ie by A LOT.
# If you want to enable swaps, consider using an edit distance of only 1, or
# better yet, dot NOT include UPPERCASE LETTERS in the error model alphabet.
#
# Possible values are 'yes' or 'no'
MOB_USE_SWAPS = no

# Default edit distanse for the generated, alphabet-based error model:
MOB_EDIT_DISTANCE = 2

# Define whether we allow changes to the initial letter(s) in the error model,
# possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
# NB!!! Setting this to anything but 'no' will greatly increase the size and
# search space of the error model, and thus make it much, much slower. Make sure
# you TEST the resulting error model properly and thoroughly, both for speed
# and suggestion quality.
MOB_INITIAL_EDITS = no

# Variable to define whether to enable edits of longer strings (as opposed to
# single letters). Possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
MOB_STRING_EDITS = txt
# Variable to specify the edit distance for the regex
# version of the strings file. The total edit distance for those operations is
# this value multiplied with the value of the EDIT_DISTANCE variable.
MOB_STRING_REGEX_EDIT_DISTANCE = 2

# Variable to define whether to enable edits of word-final strings (as opposed
# to single letters). Possible values are:
# * no    - no longer string edits = only the default, letter-based error model
# * txt   - use only the txt file as source
# * regex - use only the regex file as source
# * both  - use both the txt and regex files as sources
MOB_FINAL_STRING_EDITS = txt

# Variable to define whether to enable whole-word replacements. Possible values:
# - yes
# - no
MOB_WORD_REPLACEMENTS = yes

# Specify where to find the project.yaml file and the corresponding layout defs:
KEYBOARD_LAYOUT_DIR = $(GIELLA_CORE)/../keyboards/$GLANG
# Specify the ID of the layout as found at the top of each layout file
KEYBOARD_LAYOUT_ID = slh

# Hfst fst variables:
GT_COMMON_SPELLER_HFST = $(am__append_1)
GT_COMMON_SPELLER_NAME = speller-gt-norm
noinst_DATA = $(GT_COMMON_SPELLER_HFST) $(GT_ERRMODELS) $(INST_FILES) \
	$(GIELLA_MOBILE_SPELLER_HFST) $(MOB_GIELLA_ERRMODELS) \
	$(INST_FILES)
GIELLA_MIXED_AREA_FILTER = 

### BEGIN: AREA filter conditional:
#GIELLA_MIXED_AREA_FILTER = $(top_builddir)/src/fst/filters/remove-mixed_area-strings.hfst
GIELLA_MIXED_AREA_COMPOSE = 
#GIELLA_MIXED_AREA_COMPOSE = @\"$(top_builddir)/src/fst/filters/remove-mixed_area-strings.hfst\" .o.

# Use this as the source lexical fst for unit weighting, it contains correct
# surface forms except for the word boundary #, which is still present, and
# used in the weighting:
UW_SPELLER_SRC = .generated/generator-desktopspeller-gt-norm-base.hfst

# Set file name to the empty string or initial_letters_all depending on variable:
tag_weighted_dep = $(shell \
	if [[ $(ENABLE_CORPUS_WEIGHTS) == 'yes' ]] ; \
	then \
		echo ".generated/generator-desktopspeller-gt-norm-unit_weighted.hfst"; \
	else \
		echo ".generated/generator-desktopspeller-gt-norm-base.hfst"; \
	fi)


####### Add corpus-based weights: #######
# Use: surfweights.CORPUSNAME.hfst and CORPUSNAME.unitweight
SURFWEIGHTS = $(CORPUSNAME).surfweights.hfst
UNITWEIGHT = $(CORPUSNAME).unitweight.txt

# ALPHA for additive smoothing, [0, 1.0] seems good
ALPHA = 1.0
#NORMALISED_MAXWEIGHT=1000
corpus_size_limit_command = $(shell \
	if [[ x$(CORPUS_SIZE) != x ]] ; \
	then \
		echo "| head -n $(CORPUS_SIZE)"; \
	else \
		echo ""; \
	fi)

GT_SPELLER_HFST = generator-desktopspeller-gt-norm.hfst
GT_SPELLER_ACCEPTOR = acceptor.default.hfst

# Max compression for zipped files:
ZIPFLAGS = -9 $(VERBOSITY)

###### Conditional string variables ######

#### Swaps:
# Enable swaps depending on variable setting:
swaps = $(shell \
	if [[ $(USE_SWAPS) != 'no' ]] ; then \
		echo "--swap"; \
	else \
		echo ""; \
	fi)


#### Initial letters:
# Set file name to the empty string or initial_letters.all depending on variable:
initial_letter_deps = $(shell \
	if [[ $(INITIAL_EDITS) != 'no' ]] ; then \
		echo ".generated/initial_letters.all.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set file name to the empty string or initial_letters.all depending on variable:
initial_letter_fst_include = $(shell \
	if [[ $(INITIAL_EDITS) != 'no' ]] ; then \
		echo "( @\\\".generated/initial_letters.all.$*.hfst\\\" )"; \
	else \
		echo ""; \
	fi)


# Set python script option depending on variable:
initial_letter_error_model_option = $(shell \
	if [[ $(INITIAL_EDITS) != 'no' ]] ; then \
		echo "--no-string-initial-correction"; \
	else \
		echo ""; \
	fi)


# Set dependency file name(s) depending on variable value:
initial_letter_all_deps = $(shell \
	if   [[ $(INITIAL_EDITS) == 'regex' ]] ; then \
		echo ".generated/initial_letters.regex.%.hfst"; \
	elif [[ $(INITIAL_EDITS) == 'txt'   ]] ; then \
		echo ".generated/initial_letters.txt.%.hfst"; \
	elif [[ $(INITIAL_EDITS) == 'both'  ]] ; then \
		echo ".generated/initial_letters.regex.%.hfst .generated/initial_letters.txt.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set file name to the empty string or initial_letters.all depending on variable:
initial_letter_all_build = $(shell \
	if   [[ $(INITIAL_EDITS) == 'regex' ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(INITIAL_EDITS) == 'txt'   ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(INITIAL_EDITS) == 'both'  ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
	else \
		echo ""; \
	fi)


#### Strings:
# Set file name to the empty string or strings.all depending on variable:
strings_deps = $(shell \
	if [[ $(STRING_EDITS) != 'no' ]] ; then \
		echo ".generated/strings.all.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command for strings.all depending on variable value:
strings_fst_include = $(shell \
	if [[ $(STRING_EDITS) != 'no' ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^"; \
	else \
		echo "$(AM_V_GEN)cat $^"; \
	fi)


# Set dependency file name(s) depending on variable value:
strings_all_deps = $(shell \
	if   [[ $(STRING_EDITS) == 'regex' ]] ; then \
		echo ".generated/strings.regex.%.hfst"; \
	elif [[ $(STRING_EDITS) == 'txt'   ]] ; then \
		echo ".generated/strings.txt.%.hfst"; \
	elif [[ $(STRING_EDITS) == 'both'  ]] ; then \
		echo ".generated/strings.regex.%.hfst .generated/strings.txt.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command depending on variable:
strings_all_build = $(shell \
	if   [[ $(STRING_EDITS) == 'regex' ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(STRING_EDITS) == 'txt'   ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(STRING_EDITS) == 'both'  ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
	else \
		echo ""; \
	fi)


#### Final strings:
# Set file name to the empty string or final_strings.all depending on variable:
final_strings_deps = $(shell \
	if [[ $(FINAL_STRING_EDITS) != 'no' ]] ; then \
		echo ".generated/final_strings.all.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command for strings.all depending on variable value:
final_strings_fst_include = $(shell \
	if [[ $(FINAL_STRING_EDITS) != 'no' ]] ; then \
		echo "( @\\\".generated/final_strings.all.$*.hfst\\\" )"; \
	else \
		echo ""; \
	fi)


# Set dependency file name(s) depending on variable value:
final_strings_all_deps = $(shell \
	if   [[ $(FINAL_STRING_EDITS) == 'regex' ]] ; then \
		echo ".generated/final_strings.regex.%.hfst"; \
	elif [[ $(FINAL_STRING_EDITS) == 'txt'   ]] ; then \
		echo ".generated/final_strings.txt.%.hfst"; \
	elif [[ $(FINAL_STRING_EDITS) == 'both'  ]] ; then \
		echo ".generated/final_strings.regex.%.hfst final_strings.txt.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command depending on variable:
final_strings_all_build = $(shell \
	if   [[ $(FINAL_STRING_EDITS) == 'regex' ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(FINAL_STRING_EDITS) == 'txt'   ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(FINAL_STRING_EDITS) == 'both'  ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
	else \
		echo ""; \
	fi)


#### Whole words:
# Set file name to the empty string or words.%.txt depending on variable:
words_deps = $(shell \
	if [[ $(WORD_REPLACEMENTS) != 'no' ]] ; then \
		echo "words.%.txt"; \
	else \
		echo ""; \
	fi)


####### Automake targets: ########
GT_ERRMODELS = $(am__append_2)
# libvoikko can't yet handle multiple error models - do NOT include this line:
# errmodel.ocr.hfst
#ALL_ERRMODELS = $(GT_ERRMODELS) \
#              $(GT_ALT_ORTH_ERRMODELS) \
#			  $(GT_ALT_WS_ERRMODELS) \
#			  $(GT_AREA_ERRMODELS)


# Change errmodel.*.hfst -> easteregg.*.desktop.txt
#GIELLA_DESKTOP_EASTEREGGS = $(subst errmodel.,easteregg.,$(subst .hfst,.desktop.txt,$(ALL_ERRMODELS)))
#GT_SPELLING_HFST = $(GTLANG2).zhfst
#ALL_ZHFST_FILES = $(GT_SPELLING_HFST) \
#				 $(ALT_WS_ZHFST_FILES) \
#				 $(ALT_ORTH_ZHFST_FILES) \
#				 $(AREA_ZHFST_FILES)


# Suffix substitution to get *-desktop.zhfst for all desktop zhfst files:
#ALL_DESKTOP_ZHFST_FILES = $(ALL_ZHFST_FILES:.zhfst=-desktop.zhfst)
#voikkosharedir = $(datadir)/voikko/3/
#! @param GT_VOIKKO optional, set to spell checker automata names if
#!					installable
#voikkoshare_DATA = $(ALL_ZHFST_FILES) \
#				 $(ALL_DESKTOP_ZHFST_FILES)


#### Define variables: ####
##GT_ALT_ORTH_ERRMODELS = $(shell for ld in $(ALT_ORTHS); do\
##    echo ".generated/errmodel.$$ld.hfst" ; \
##done)

##GT_ALT_ORTH_SPELLER_ACCEPTORS = $(shell for ld in $(ALT_ORTHS); do\
##    echo ".generated/acceptor.$$ld.hfst" ; \
##done)

##ALT_ORTH_ZHFST_FILES = $(shell for ld in $(ALT_ORTHS); do\
##    echo "$(GTLANG2)-x-$$ld.zhfst" ; \
##done)

##ALT_ORTH_ZHFST_BASENAMES = $(basename $(ALT_ORTH_ZHFST_FILES))

#### Define variables: ####
##GT_ALT_WS_ERRMODELS = $(shell for ld in $(ALT_WSS); do\
##    echo ".generated/errmodel.$$ld.hfst" ; \
##done)

##GT_ALT_WS_SPELLER_ACCEPTORS = $(shell for ld in $(ALT_WSS); do\
##    echo ".generated/acceptor.$$ld.hfst" ; \
##done)

##ALT_WS_ZHFST_FILES = $(shell for ld in $(ALT_WSS); do\
##    echo "$(GTLANG2)-$$ld.zhfst" ; \
##done)

##ALT_WS_ZHFST_BASENAMES = $(basename $(ALT_WS_ZHFST_FILES))

#### Define variables: ####
##GT_AREA_ERRMODELS = $(shell for ld in $(AREAS); do\
##    echo ".generated/errmodel.$$ld.hfst" ; \
##done)

##GT_AREA_SPELLER_ACCEPTORS = $(shell for ld in $(AREAS); do\
##    echo ".generated/acceptor.$$ld.hfst" ; \
##done)

##AREA_ZHFST_FILES = $(shell for ld in $(AREAS); do\
##    echo "$(GTLANG2)_$$ld.zhfst" ; \
##done)

##AREA_ZHFST_BASENAMES = $(basename $(AREA_ZHFST_FILES))

# Hfst fst variables:
GIELLA_MOBILE_SPELLER_HFST = $(am__append_3)

# Use this as the source lexical fst for unit weighting, it contains correct
# surface forms except for the word boundary #, which is still present, and
# used in the weighting:
MOB_UW_SPELLER_SRC = generator-mobilespeller-gt-norm-base.hfst

# Set file name to the empty string or initial_letters_all depending on variable:
mob_tag_weighted_dep = $(shell \
	if [[ $(ENABLE_MOB_CORPUS_WEIGHTS) == 'yes' ]] ; \
	then \
		echo "generator-mobilespeller-gt-norm-unit_weighted.hfst"; \
	else \
		echo "generator-mobilespeller-gt-norm-base.hfst"; \
	fi)


####### Add corpus-based weights: #######
# Use: surfweights.MOBILE_CORPUSNAME.hfst and MOBILE_CORPUSNAME.unitweight
MOB_SURFWEIGHTS = mob_$(MOBILE_CORPUSNAME).surfweights.hfst
MOB_UNITWEIGHT = mob_$(MOBILE_CORPUSNAME).unitweight.txt

# We use same ALPHA for both mobile and desktop spellers, simplifies fst builds
# # ALPHA for additive smoothing, [0, 1.0] seems good
# ALPHA=1.0

#NORMALISED_MAXWEIGHT=1000
mob_corpus_size_limit_command = $(shell \
	if [[ x$(MOB_CORPUS_SIZE) != x ]] ; \
	then \
		echo "| head -n $(MOB_CORPUS_SIZE)"; \
	else \
		echo ""; \
	fi)

MOB_GT_SPELLER_HFST = generator-mobilespeller-gt-norm.hfst
MOB_GT_SPELLER_ACCEPTOR = acceptor.default.mobile.hfst
MOB_GT_PREDICT_ACCEPTOR = acceptor.default.predict.hfst

# Zero compression for mobile zhfst files:
MOB_ZIPFLAGS = -0 $(VERBOSITY)

# Use zip with zero compression for best performance on mobile phones:
ZHFST_COMPRESSION = $(ZIP) $(MOB_ZIPFLAGS) ../../$@ *

# Other external tools and paths needed for mobile spellers:
KBDGEN = kbdgen

###### Conditional string variables ######

#### Swaps:
# Enable swaps depending on variable setting:
mob_swaps = $(shell \
	if [[ $(MOB_USE_SWAPS) != 'no' ]] ; then \
		echo "--swap"; \
	else \
		echo ""; \
	fi)


#### Initial letters:
# Set file name to the empty string or initial_letters.all depending on variable:
mob_initial_letter_deps = $(shell \
	if [[ $(MOB_INITIAL_EDITS) != 'no' ]] ; then \
		echo "initial_letters.all.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set file name to the empty string or initial_letters.all depending on variable:
mob_initial_letter_fst_include = $(shell \
	if [[ $(MOB_INITIAL_EDITS) != 'no' ]] ; then \
		echo "( @\\\"initial_letters.all.$*.hfst\\\" )"; \
	else \
		echo ""; \
	fi)


# Set python script option depending on variable:
mob_initial_letter_error_model_option = $(shell \
	if [[ $(MOB_INITIAL_EDITS) != 'no' ]] ; then \
		echo "--no-string-initial-correction"; \
	else \
		echo ""; \
	fi)


#mob_initial_letter_all_deps=$(shell \
#	if   [[ $(MOB_INITIAL_EDITS) == 'regex' ]] ; then \
#		echo "initial_letters.regex.%.hfst"; \
#	elif [[ $(MOB_INITIAL_EDITS) == 'txt'   ]] ; then \
#		echo "initial_letters.txt.%.hfst"; \
#	elif [[ $(MOB_INITIAL_EDITS) == 'both'  ]] ; then \
#		echo "initial_letters.regex.%.hfst initial_letters.txt.%.hfst"; \
#	else \
#		echo ""; \
#	fi)

#mob_initial_letter_all_build=$(shell \
#	if   [[ $(MOB_INITIAL_EDITS) == 'regex' ]] ; then \
#		echo "$(AM_V_CP)cp -f $< $@"; \
#	elif [[ $(MOB_INITIAL_EDITS) == 'txt'   ]] ; then \
#		echo "$(AM_V_CP)cp -f $< $@"; \
#	elif [[ $(MOB_INITIAL_EDITS) == 'both'  ]] ; then \
#		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
#	else \
#		echo ""; \
#	fi)

#### Strings:
# Set file name to the empty string or strings.all.%.mobile.hfst depending on variable:
#mob_strings_deps=$(shell \
#	if [[ $(MOB_STRING_EDITS) != 'no' ]] ; then \
#		echo "strings.all.%.mobile.hfst"; \
#	else \
#		echo ""; \
#	fi)

#mob_strings_fst_include=$(shell \
#	if [[ $(MOB_STRING_EDITS) != 'no' ]] ; then \
#		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^"; \
#	else \
#		echo "$(AM_V_GEN)cat $^"; \
#	fi)

# Set dependency file name(s) depending on variable value:
mob_strings_all_deps = $(shell \
	if   [[ $(MOB_STRING_EDITS) == 'regex' ]] ; then \
		echo "strings.regex.%.mobile.hfst"; \
	elif [[ $(MOB_STRING_EDITS) == 'txt'   ]] ; then \
		echo "strings.txt.%.mobile.hfst"; \
	elif [[ $(MOB_STRING_EDITS) == 'both'  ]] ; then \
		echo "strings.regex.%.mobile.hfst strings.txt.%.mobile.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command depending on variable:
mob_strings_all_build = $(shell \
	if   [[ $(MOB_STRING_EDITS) == 'regex' ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(MOB_STRING_EDITS) == 'txt'   ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(MOB_STRING_EDITS) == 'both'  ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
	else \
		echo ""; \
	fi)


#### Final strings:
# Set file name to the empty string or final_strings.all depending on variable:
mob_final_strings_deps = $(shell \
	if [[ $(MOB_FINAL_STRING_EDITS) != 'no' ]] ; then \
		echo ".generated/final_strings.all.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command for strings.all depending on variable value:
mob_final_strings_fst_include = $(shell \
	if [[ $(MOB_FINAL_STRING_EDITS) != 'no' ]] ; then \
		echo "( @\\\".generated/final_strings.all.$*.hfst\\\" )"; \
	else \
		echo ""; \
	fi)


# Set dependency file name(s) depending on variable value:
mob_final_strings_all_deps = $(shell \
	if   [[ $(MOB_FINAL_STRING_EDITS) == 'regex' ]] ; then \
		echo ".generated/final_strings.regex.%.hfst"; \
	elif [[ $(MOB_FINAL_STRING_EDITS) == 'txt'   ]] ; then \
		echo ".generated/final_strings.txt.%.hfst"; \
	elif [[ $(MOB_FINAL_STRING_EDITS) == 'both'  ]] ; then \
		echo ".generated/final_strings.regex.%.hfst .generated/final_strings.txt.%.hfst"; \
	else \
		echo ""; \
	fi)


# Set build command depending on variable:
mob_final_strings_all_build = $(shell \
	if   [[ $(MOB_FINAL_STRING_EDITS) == 'regex' ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(MOB_FINAL_STRING_EDITS) == 'txt'   ]] ; then \
		echo "$(AM_V_CP)cp -f $< $@"; \
	elif [[ $(MOB_FINAL_STRING_EDITS) == 'both'  ]] ; then \
		echo "$(AM_V_UNION)$(HFST_DISJUNCT) $^ -o $@"; \
	else \
		echo ""; \
	fi)


#### Whole words:
# Set file name to the empty string or words.%.txt depending on variable:
mob_words_deps = $(shell \
	if [[ $(MOB_WORD_REPLACEMENTS) != 'no' ]] ; then \
		echo "words.%.mobile.txt"; \
	else \
		echo ""; \
	fi)


####### Automake targets: ########
MOB_GIELLA_ERRMODELS = $(am__append_4)
MOB_GIELLA_PREDICTMODELS = $(am__append_5)

# Change errmodel.*.hfst -> easteregg.*.desktop.txt
##GIELLA_MOBILE_EASTEREGGS = $(subst errmodel.,easteregg.,$(subst .mobile.hfst,.mobile.txt,$(MOB_GIELLA_ERRMODELS)))
##MOB_GIELLA_SPELLING_HFST = $(GTLANG2)-mobile.zhfst
##MOB_GIELLA_PREDICT_HFST = $(GTLANG2)-x-predict-mobile.zhfst
##mobilespellerdir = $(datadir)/giella/mobilespellers/
#! @param GT_VOIKKO optional, set to spell checker automata names if
#!					installable
##mobilespeller_DATA = $(MOB_GIELLA_SPELLING_HFST) $(MOB_GIELLA_PREDICT_HFST) \
##				   $(ALT_WS_ZHFST_FILES) $(ALT_ORTH_ZHFST_FILES)

HFST_FORMAT = --format=foma
#HFST_FORMAT = --format=openfst-log
#HFST_FORMAT = --format=openfst-tropical
#HFST_FORMAT = --format=sfst
HFST_OLFORMAT = --format=optimized-lookup-unweighted
#HFST_OLFORMAT = --format=optimized-lookup-weighted
#HFST_OLFORMAT = --format=optimized-lookup-weighted
#HFST_OLFORMAT = --format=optimized-lookup-unweighted

# hfst-compose:
AM_V_COMPOSE = $(AM_V_COMPOSE_$(V))
AM_V_COMPOSE_ = $(AM_V_COMPOSE_$(AM_DEFAULT_VERBOSITY))
AM_V_COMPOSE_0 = @echo "  HCOMPOSE $@";

# hfst-concatenate:
AM_V_HCONCAT = $(AM_V_HCONCAT_$(V))
AM_V_HCONCAT_ = $(AM_V_HCONCAT_$(AM_DEFAULT_VERBOSITY))
AM_V_HCONCAT_0 = @echo "  HCONCAT  $@";

# hfst-conjunct /
# hfst-intersect:
AM_V_CONJCT = $(AM_V_CONJCT_$(V))
AM_V_CONJCT_ = $(AM_V_CONJCT_$(AM_DEFAULT_VERBOSITY))
AM_V_CONJCT_0 = @echo "  HCONJCT  $@";

# hfst-fst2fst:
AM_V_FST2FST = $(AM_V_FST2FST_$(V))
AM_V_FST2FST_ = $(AM_V_FST2FST_$(AM_DEFAULT_VERBOSITY))
AM_V_FST2FST_0 = @echo "  HFST2FST $@";

# hfst-minimize
AM_V_HMINIM = $(AM_V_HMINIM_$(V))
AM_V_HMINIM_ = $(AM_V_HMINIM_$(AM_DEFAULT_VERBOSITY))
AM_V_HMINIM_0 = @echo "  HMINIM   $@";

# hfst-fst2txt:
AM_V_FST2TXT = $(AM_V_FST2TXT_$(V))
AM_V_FST2TXT_ = $(AM_V_FST2TXT_$(AM_DEFAULT_VERBOSITY))
AM_V_FST2TXT_0 = @echo "  HFST2TXT $@";

# hfst-foma:
AM_V_HFOMA = $(AM_V_HFOMA_$(V))
AM_V_HFOMA_ = $(AM_V_HFOMA_$(AM_DEFAULT_VERBOSITY))
AM_V_HFOMA_0 = @echo "  HFOMA    $@";

# hfst-optimized-lookup:
AM_V_HFSTOL = $(AM_V_HFSTOL_$(V))
AM_V_HFSTOL_ = $(AM_V_HFSTOL_$(AM_DEFAULT_VERBOSITY))
AM_V_HFSTOL_0 = @echo "  HFSTOL   $@";

# hfst-lexc:
AM_V_HLEXC = $(AM_V_HLEXC_$(V))
AM_V_HLEXC_ = $(AM_V_HLEXC_$(AM_DEFAULT_VERBOSITY))
AM_V_HLEXC_0 = @echo "  HLEXC    $@";

# hfst-split:
AM_V_HSPLIT = $(AM_V_HSPLIT_$(V))
AM_V_HSPLIT_ = $(AM_V_HSPLIT_$(AM_DEFAULT_VERBOSITY))
AM_V_HSPLIT_0 = @echo "  HSPLIT   $@";

# hfst-substitute:
AM_V_HSUBST = $(AM_V_HSUBST_$(V))
AM_V_HSUBST_ = $(AM_V_HSUBST_$(AM_DEFAULT_VERBOSITY))
AM_V_HSUBST_0 = @echo "  HSUBST   $@";

# hfst-twolc:
AM_V_HTWOLC = $(AM_V_HTWOLC_$(V))
AM_V_HTWOLC_ = $(AM_V_HTWOLC_$(AM_DEFAULT_VERBOSITY))
AM_V_HTWOLC_0 = @echo "  HTWOLC   $@";

# hfst-xfst:
AM_V_HXFST = $(AM_V_HXFST_$(V))
AM_V_HXFST_ = $(AM_V_HXFST_$(AM_DEFAULT_VERBOSITY))
AM_V_HXFST_0 = @echo "  HXFST    $@";

# hfst-compose-intersect:
AM_V_INTRSCT = $(AM_V_INTRSCT_$(V))
AM_V_INTRSCT_ = $(AM_V_INTRSCT_$(AM_DEFAULT_VERBOSITY))
AM_V_INTRSCT_0 = @echo "  HINTRSCT $@";

# hfst-invert:
AM_V_INVERT = $(AM_V_INVERT_$(V))
AM_V_INVERT_ = $(AM_V_INVERT_$(AM_DEFAULT_VERBOSITY))
AM_V_INVERT_0 = @echo "  HINVERT  $@";

# hfst-pmatch2fst
AM_V_PM2FST = $(AM_V_PM2FST_$(V))
AM_V_PM2FST_ = $(AM_V_PM2FST_$(AM_DEFAULT_VERBOSITY))
AM_V_PM2FST_0 = @echo "  HPM2FST  $@";

# hfst-project:
AM_V_PROJECT = $(AM_V_PROJECT_$(V))
AM_V_PROJECT_ = $(AM_V_PROJECT_$(AM_DEFAULT_VERBOSITY))
AM_V_PROJECT_0 = @echo "  HPROJECT $@";

# hfst-prune-alphabet
AM_V_HPRUNE = $(AM_V_HPRUNE_$(V))
AM_V_HPRUNE_ = $(AM_V_HPRUNE_$(AM_DEFAULT_VERBOSITY))
AM_V_HPRUNE_0 = @echo "  HPRUNE   $@";

# hfst-reverse
AM_V_REVERSE = $(AM_V_REVERSE_$(V))
AM_V_REVERSE_ = $(AM_V_REVERSE_$(AM_DEFAULT_VERBOSITY))
AM_V_REVERSE_0 = @echo "  HREVERSE $@";

# hfst-reweight:
AM_V_REWEIGHT = $(AM_V_REWEIGHT_$(V))
AM_V_REWEIGHT_ = $(AM_V_REWEIGHT_$(AM_DEFAULT_VERBOSITY))
AM_V_REWEIGHT_0 = @echo "  HREWGHT  $@";

# hfst-regexp2fst:
AM_V_RGX2FST = $(AM_V_RGX2FST_$(V))
AM_V_RGX2FST_ = $(AM_V_RGX2FST_$(AM_DEFAULT_VERBOSITY))
AM_V_RGX2FST_0 = @echo "  HRGX2FST $@";

# hfst-repeat
AM_V_REPEAT = $(AM_V_REPEAT_$(V))
AM_V_REPEAT_ = $(AM_V_REPEAT_$(AM_DEFAULT_VERBOSITY))
AM_V_REPEAT_0 = @echo "  HREPEAT  $@";

# hfst-strings2fst:
AM_V_STR2FST = $(AM_V_STR2FST_$(V))
AM_V_STR2FST_ = $(AM_V_STR2FST_$(AM_DEFAULT_VERBOSITY))
AM_V_STR2FST_0 = @echo "  HSTR2FST $@";

# hfst-txt2fst:
AM_V_TXT2FST = $(AM_V_TXT2FST_$(V))
AM_V_TXT2FST_ = $(AM_V_TXT2FST_$(AM_DEFAULT_VERBOSITY))
AM_V_TXT2FST_0 = @echo "  HTXT2FST $@";

# hfst-union / hfst-disjunct:
AM_V_UNION = $(AM_V_UNION_$(V))
AM_V_UNION_ = $(AM_V_UNION_$(AM_DEFAULT_VERBOSITY))
AM_V_UNION_0 = @echo "  HUNION   $@";

#### LexD (Apertium)
AM_V_LEXD = $(AM_V_LEXD_$(V))
AM_V_LEXD_ = $(AM_V_LEXD_$(AM_DEFAULT_VERBOSITY))
AM_V_LEXD_0 = @echo "  LEXD     $@";

#### Foma
AM_V_FOMA = $(AM_V_FOMA_$(V))
AM_V_FOMA_ = $(AM_V_FOMA_$(AM_DEFAULT_VERBOSITY))
AM_V_FOMA_0 = @echo "  FOMA     $@";

#### Xerox tools
AM_V_TWOLC = $(AM_V_TWOLC_$(V))
AM_V_TWOLC_ = $(AM_V_TWOLC_$(AM_DEFAULT_VERBOSITY))
AM_V_TWOLC_0 = @echo "  TWOLC    $@";
AM_V_LEXC = $(AM_V_LEXC_$(V))
AM_V_LEXC_ = $(AM_V_LEXC_$(AM_DEFAULT_VERBOSITY))
AM_V_LEXC_0 = @echo "  LEXC     $@";
AM_V_XFST = $(AM_V_XFST_$(V))
AM_V_XFST_ = $(AM_V_XFST_$(AM_DEFAULT_VERBOSITY))
AM_V_XFST_0 = @echo "  XFST     $@";

#### VislCG3
AM_V_CGCOMP = $(AM_V_CGCOMP_$(V))
AM_V_CGCOMP_ = $(AM_V_CGCOMP_$(AM_DEFAULT_VERBOSITY))
AM_V_CGCOMP_0 = @echo "  CG3COMP  $@";

#### Other tools
AM_V_CP = $(AM_V_CP_$(V))
AM_V_CP_ = $(AM_V_CP_$(AM_DEFAULT_VERBOSITY))
AM_V_CP_0 = @echo "  CP       $@";
AM_V_MV = $(AM_V_MV_$(V))
AM_V_MV_ = $(AM_V_MV_$(AM_DEFAULT_VERBOSITY))
AM_V_MV_0 = @echo "  MV       $@";
AM_V_GZIP = $(AM_V_GZIP_$(V))
AM_V_GZIP_ = $(AM_V_GZIP_$(AM_DEFAULT_VERBOSITY))
AM_V_GZIP_0 = @echo "  GZIP     $@";
AM_V_ZIP = $(AM_V_ZIP_$(V))
AM_V_ZIP_ = $(AM_V_ZIP_$(AM_DEFAULT_VERBOSITY))
AM_V_ZIP_0 = @echo "  ZIP      $@";
AM_V_SAXON = $(AM_V_SAXON_$(V))
AM_V_SAXON_ = $(AM_V_SAXON_$(AM_DEFAULT_VERBOSITY))
AM_V_SAXON_0 = @echo "  SAXON    $@";
AM_V_XSLPROC = $(AM_V_XSLPROC_$(V))
AM_V_XSLPROC_ = $(AM_V_XSLPROC_$(AM_DEFAULT_VERBOSITY))
AM_V_XSLPROC_0 = @echo "  XSLPROC  $@";
AM_V_AWK = $(AM_V_AWK_$(V))
AM_V_AWK_ = $(AM_V_AWK_$(AM_DEFAULT_VERBOSITY))
AM_V_AWK_0 = @echo "  AWK      $@";
AM_V_SED = $(AM_V_SED_$(V))
AM_V_SED_ = $(AM_V_SED_$(AM_DEFAULT_VERBOSITY))
AM_V_SED_0 = @echo "  SED      $@";
AM_V_FORREST = $(AM_V_FORREST_$(V))
AM_V_FORREST_ = $(AM_V_FORREST_$(AM_DEFAULT_VERBOSITY))
AM_V_FORREST_0 = @echo "  FORREST  $@";

# Let the verbosity of some command line tools follow the automake verbosity.
# VERBOSITY       = be quiet if V=0, unspecified otherwise
# MORE_VERBOSITY  = be quiet if V=0, be verbose otherwise
VERBOSITY = $(if $(strip $(filter-out false,$(AM_V_P))), ,-q)
MORE_VERBOSITY = $(if $(strip $(filter-out false,$(AM_V_P))),-v,-q)

# either depend on $(GENDIR) or $(MAKE) $(GENDIR) when using temporary files in
# gendir.
GENDIR = .generated/.stamp
all: all-recursive

.SUFFIXES:
.SUFFIXES: .foma .hfst .regex .xfst
$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am $(srcdir)/Makefile.mod-spellcheckers.am $(srcdir)/Makefile.mod-fstbased.am $(srcdir)/Makefile.mod-desktop.am $(srcdir)/Makefile.mod-desktop-hfst.am $(srcdir)/Makefile.mod-mobile.am $(srcdir)/Makefile.mod-mobile-hfst.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop_weights-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_orth-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_ws-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_area-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile_weights-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-hfst-dir-include.am $(top_srcdir)/../giella-core/am-shared/regex-include.am $(top_srcdir)/../giella-core/am-shared/xfscript-include.am $(top_srcdir)/../giella-core/am-shared/hfst-format-include.am $(top_srcdir)/../giella-core/am-shared/silent_build-include.am $(top_srcdir)/../giella-core/am-shared/dot-generated-dir.am $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign tools/spellcheckers/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --foreign tools/spellcheckers/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
	esac;
$(srcdir)/Makefile.mod-spellcheckers.am $(srcdir)/Makefile.mod-fstbased.am $(srcdir)/Makefile.mod-desktop.am $(srcdir)/Makefile.mod-desktop-hfst.am $(srcdir)/Makefile.mod-mobile.am $(srcdir)/Makefile.mod-mobile-hfst.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop_weights-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_orth-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_alt_ws-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-desktop-hfst_area-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile_weights-dir-include.am $(top_srcdir)/../giella-core/am-shared/tools-spellcheckers-fstbased-mobile-hfst-dir-include.am $(top_srcdir)/../giella-core/am-shared/regex-include.am $(top_srcdir)/../giella-core/am-shared/xfscript-include.am $(top_srcdir)/../giella-core/am-shared/hfst-format-include.am $(top_srcdir)/../giella-core/am-shared/silent_build-include.am $(top_srcdir)/../giella-core/am-shared/dot-generated-dir.am $(am__empty):

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure:  $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):
index.xml: $(top_builddir)/config.status $(srcdir)/index.xml.in
	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
index.mobile.xml: $(top_builddir)/config.status $(srcdir)/index.mobile.xml.in
	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
install-mobilespellerDATA: $(mobilespeller_DATA)
	@$(NORMAL_INSTALL)
	@list='$(mobilespeller_DATA)'; test -n "$(mobilespellerdir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(mobilespellerdir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(mobilespellerdir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(mobilespellerdir)'"; \
	  $(INSTALL_DATA) $$files "$(DESTDIR)$(mobilespellerdir)" || exit $$?; \
	done

uninstall-mobilespellerDATA:
	@$(NORMAL_UNINSTALL)
	@list='$(mobilespeller_DATA)'; test -n "$(mobilespellerdir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(mobilespellerdir)'; $(am__uninstall_files_from_dir)
install-voikkoshareDATA: $(voikkoshare_DATA)
	@$(NORMAL_INSTALL)
	@list='$(voikkoshare_DATA)'; test -n "$(voikkosharedir)" || list=; \
	if test -n "$$list"; then \
	  echo " $(MKDIR_P) '$(DESTDIR)$(voikkosharedir)'"; \
	  $(MKDIR_P) "$(DESTDIR)$(voikkosharedir)" || exit 1; \
	fi; \
	for p in $$list; do \
	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
	  echo "$$d$$p"; \
	done | $(am__base_list) | \
	while read files; do \
	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(voikkosharedir)'"; \
	  $(INSTALL_DATA) $$files "$(DESTDIR)$(voikkosharedir)" || exit $$?; \
	done

uninstall-voikkoshareDATA:
	@$(NORMAL_UNINSTALL)
	@list='$(voikkoshare_DATA)'; test -n "$(voikkosharedir)" || list=; \
	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
	dir='$(DESTDIR)$(voikkosharedir)'; $(am__uninstall_files_from_dir)

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
distdir: $(BUILT_SOURCES)
	$(MAKE) $(AM_MAKEFLAGS) distdir-am

distdir-am: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(DATA)
installdirs: installdirs-recursive
installdirs-am:
	for dir in "$(DESTDIR)$(mobilespellerdir)" "$(DESTDIR)$(voikkosharedir)"; do \
	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
	done
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-local mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am: install-mobilespellerDATA install-voikkoshareDATA

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am: uninstall-mobilespellerDATA uninstall-voikkoshareDATA

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-local cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-tags distdir \
	dvi dvi-am html html-am info info-am install install-am \
	install-data install-data-am install-dvi install-dvi-am \
	install-exec install-exec-am install-html install-html-am \
	install-info install-info-am install-man \
	install-mobilespellerDATA install-pdf install-pdf-am \
	install-ps install-ps-am install-strip install-voikkoshareDATA \
	installcheck installcheck-am installdirs installdirs-am \
	maintainer-clean maintainer-clean-generic mostlyclean \
	mostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am uninstall-mobilespellerDATA \
	uninstall-voikkoshareDATA

.PRECIOUS: Makefile


# END: Local processing
#########################################

#### END: Local build rules: *.hfst: *.tmp.hfst ####

### BEGIN: Local build rules: *.hfst: *.tmp.hfst ###

# vim: set ft=automake:

### BEGIN: Local build rules: *.hfst: *.tmp.hfst ###

#### END: Local build rules: *.hfst: *.tmp.hfst ####

# vim: set ft=automake:

# Build the common speller transducer by removing everything we don't want in
# any of the spellers:
.generated/generator-$(GT_COMMON_SPELLER_NAME).tmp.hfst: \
			$(top_builddir)/src/fst/analyser-raw-gt-desc.hfst                     \
			$(top_builddir)/src/fst/filters/remove-CLB-strings.hfst               \
			$(top_builddir)/src/fst/filters/remove-error-strings.hfst             \
			$(top_builddir)/src/fst/filters/remove-MinusSpell-strings.hfst        \
			$(top_builddir)/src/fst/filters/remove-PUNCT-strings.hfst             \
			$(top_builddir)/src/fst/filters/remove-use_marg-strings.hfst          \
			$(top_builddir)/src/fst/filters/remove-orig_lang-tags.hfst            \
			$(top_builddir)/src/fst/filters/remove-usage_except_speller-tags.hfst \
			$(top_builddir)/src/fst/filters/remove-Use_GC-strings.hfst            \
			$(top_builddir)/src/fst/filters/remove-Use_minusGC-tags.hfst          \
			$(top_builddir)/src/fst/filters/remove-Use_minus_PMatch-tags.hfst     \
			$(top_builddir)/src/fst/filters/remove-Use_PMatch-strings.hfst        \
			$(top_builddir)/src/fst/filters/remove-use_mt-strings.hfst            \
			$(top_builddir)/src/fst/filters/remove-mwe-tags.hfst                  \
			$(top_builddir)/src/fst/orthography/downcase-derived_proper-strings.compose.hfst \
			$(GENDIR)
	$(AM_V_XFST_TOOL)$(PRINTF) "read regex \
		    @\"$(top_builddir)/src/fst/filters/remove-usage_except_speller-tags.hfst\" \
		.o. @\"$(top_builddir)/src/fst/filters/remove-orig_lang-tags.hfst\"        \
		.o. @\"$(top_builddir)/src/fst/filters/remove-CLB-strings.hfst\"           \
		.o. @\"$(top_builddir)/src/fst/filters/remove-error-strings.hfst\"         \
		.o. @\"$(top_builddir)/src/fst/filters/remove-MinusSpell-strings.hfst\"    \
		.o. @\"$(top_builddir)/src/fst/filters/remove-PUNCT-strings.hfst\"         \
		.o. @\"$(top_builddir)/src/fst/filters/remove-use_marg-strings.hfst\"      \
		.o. @\"$(top_builddir)/src/fst/filters/remove-Use_minus_PMatch-tags.hfst\" \
		.o. @\"$(top_builddir)/src/fst/filters/remove-Use_minusGC-tags.hfst\"      \
		.o. @\"$(top_builddir)/src/fst/filters/remove-Use_GC-strings.hfst\"        \
		.o. @\"$(top_builddir)/src/fst/filters/remove-Use_PMatch-strings.hfst\"    \
		.o. @\"$(top_builddir)/src/fst/filters/remove-mwe-tags.hfst\"              \
		.o. @\"$(top_builddir)/src/fst/filters/remove-use_mt-strings.hfst\"        \
		.o. @\"$<\" \
		.o. @\"$(top_builddir)/src/fst/orthography/downcase-derived_proper-strings.compose.hfst\" \
		;\n\
		 save stack $@\n\
		 quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY) $(HFST_FORMAT)

# Copy the tmp transducer to the final one. This allows local overrides.
.generated/%.hfst: .generated/%.tmp.hfst
	$(AM_V_CP)cp -f $< $@

# Invert the final fst, to enable symmetric yaml tests and easy manual testing:
.generated/analyser-%.hfst: .generated/generator-%.hfst
	$(AM_V_INVERT)$(HFST_INVERT) $(MORE_VERBOSITY) $(HFST_FLAGS) -i $< -o $@

####### Other targets: ###########

# Keep these intermediate targets when building using --debug:
.SECONDARY: editdist.all.default.hfst \
            strings.default.hfst     \
            editdist.default.hfst    \
            editdist.default.regex    \
            words.default.hfst \
            initial_letters.list.default.hfst \
            initial_letters.regex.default.hfst \
            initial_letters.all.default.hfst \
            final_strings.default.hfst

#### Build the speller transducer with compound filtering:
.generated/generator-fstspeller-gt-norm.tmp.hfst: \
			generator-speller-gt-norm.hfst \
			$(top_builddir)/src/fst/filters/remove-hyphenation-marks.hfst  \
			$(top_builddir)/src/fst/filters/remove-infl_deriv-borders.hfst \
			$(GIELLA_MIXED_AREA_FILTER) $(GENDIR)
	$(AM_V_HXFST)$(PRINTF) "read regex                                        \
			$(GIELLA_MIXED_AREA_COMPOSE)                                      \
			@\"$<\"                                                           \
		.o. @\"$(top_builddir)/src/fst/filters/remove-hyphenation-marks.hfst\"    \
		.o. @\"$(top_builddir)/src/fst/filters/remove-infl_deriv-borders.hfst\"   \
		; \n\
		 twosided flag-diacritics\n\
		 save stack $@\n\
		 quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY) $(HFST_FORMAT)

#### 1. Copy base fst from parent dir:
.generated/generator-desktopspeller-gt-norm-base.hfst: .generated/generator-fstspeller-gt-norm.hfst
	$(AM_V_FST2FST)$(HFST_FST2FST) --format=openfst-tropical -i $< -o $@

#### 2. Add corpus-based frequency weights (all non-hits will disappear from
####    the fst):
.generated/generator-desktopspeller-gt-norm-freq_weighted.hfst: \
				 .generated/generator-desktopspeller-gt-norm-base.hfst \
				 $(SURFWEIGHTS)
	$(AM_V_COMPOSE)$(HFST_COMPOSE) $(HFST_FLAGS) -F \
			$< $(SURFWEIGHTS) \
		-o $@

#### 3. Add a default unit weight to anything not covered by the corpus
####    by combining (unioning) the unitweighted.hfst (which is the full
####    lexical fst) with the frequency/corpus-based fst - use priority
####    union to avoid duplication of paths and thus make a mutch smaller
####    (and hence faster) fst:
####
#### Future plan: replace standard union | with priority union .P., when it
#### works properly for weighted fst's.
.generated/generator-desktopspeller-gt-norm-unit_weighted.hfst: \
				 .generated/generator-desktopspeller-gt-norm-freq_weighted.hfst \
				 .generated/unitweighted.hfst
	$(AM_V_HXFST)$(PRINTF) "\
	set encode-weights ON \n\
	read regex \
		@\"$<\" \
	|   @\".generated/unitweighted.hfst\"  \
	; \n\
	save stack $@\n\
	quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY)

#### 4. Add tag-based weights, for adjusting weights according to morphology
####    and other tag-based penalties like words that should not be suggested:
.generated/generator-desktopspeller-gt-norm-tag_weighted.hfst: $(tag_weighted_dep)  \
				 	 $(srcdir)/weights/$(TAGWEIGHTS)
	$(AM_V_REWEIGHT)$(HFST_REWEIGHT) $(MORE_VERBOSITY) $(HFST_FLAGS) \
			-T $(srcdir)/weights/$(TAGWEIGHTS) --arcs-only -i $< \
		-o $@

#### 5. Finally, remove the surface word boundary symbol and do other
####    general cleanup:
.generated/generator-desktopspeller-gt-norm.tmp.hfst: \
			.generated/generator-desktopspeller-gt-norm-tag_weighted.hfst \
			filters/remove-word-boundary.hfst \
			filters/remove-usage-tags.hfst \
			.generated/easteregg.default.desktop.hfst
	$(AM_V_HXFST)$(PRINTF) "\
	set encode-weights ON \n\
	read regex [ \
	    @\"filters/remove-usage-tags.hfst\" \
	.o. @\"$<\" \
	.o. @\"filters/remove-word-boundary.hfst\" ] \
	| @\".generated/easteregg.default.desktop.hfst\" \
	; \n\
	save stack $@\n\
	quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY)

# Copy the tmp transducer to the final one. This allows local overrides.
.generated/%.hfst: .generated/%.tmp.hfst
	$(AM_V_CP)cp -f $< $@

# Invert the final fst, to enable symmetric yaml tests and easy manual testing:
.generated/analyser-desktopspeller-gt-norm.hfst: .generated/generator-desktopspeller-gt-norm.hfst
	$(AM_V_INVERT)$(HFST_INVERT) $(MORE_VERBOSITY) $(HFST_FLAGS) -i $< \
	| $(HFST_PRUNE_ALPHABET) $(MORE_VERBOSITY) \
	| $(HFST_REMOVE_EPSILONS) $(MORE_VERBOSITY) -o $@

.generated/%.hfst: weights/%.att $(GENDIR)
	$(AM_V_GEN)$(HFST_TXT2FST) $(HFST_FLAGS) -f openfst-tropical $< -o $@

# sort the clean corpus:
.generated/%.sort.txt: weights/%.clean.txt
	$(AM_V_GEN)LC_ALL=C.utf8 sort < $< > $@

# token count:
.generated/%.wordcount.txt: .generated/%.sort.txt
	$(AM_V_GEN)wc -l < $< > $@

# Unique the sorted, clean corpus:
.generated/%.uniq.txt: .generated/%.sort.txt
	$(AM_V_GEN)LC_ALL=C.utf8 uniq -c < $< |\
		LC_ALL=C.utf8 sort -nr $(corpus_size_limit_command) > $@

# type count:
.generated/%.typecount.txt: .generated/%.uniq.txt
	$(AM_V_GEN)wc -l < $< > $@

# calculate unit weight, smoothed using ALPHA:
#%.unitweight.txt: %.wordcount.txt %.typecount.txt
#	$(AM_V_GEN)paste $^ |\
#		sed -e "s/^/scale=5; -l($(ALPHA)\/(/" \
#		    -e "s/	/ + ($(ALPHA) */" -e "s/$$/)))/" \
#		| $(BC) -l > $@

# Alternative unit weight: highest tropical weight + ALPHA:
.generated/%.unitweight.txt: .generated/%.tropical.txt
	$(AM_V_GEN)echo "$$(cut -f2 < $^ | sort -nru | head -n1) + $(ALPHA)" \
		| $(BC) -l > $@

# add tropical weights to the corpus:
.generated/%.tropical.txt: .generated/%.uniq.txt .generated/%.wordcount.txt .generated/%.typecount.txt
	$(AM_V_GEN)cat $< |\
		$(GAWK) -v CS="$$(cat .generated/$*.wordcount.txt)" \
				-v DS="$$(cat .generated/$*.typecount.txt)" \
				-v ALPHA=$(ALPHA)                \
				-f $(GTCORE)/scripts/uniq_count2tropical_weight.awk \
				> $@

# build an fst of surface forms with tropical weights for each word form:
.generated/%.surfs.hfst: .generated/%.tropical.txt
	$(AM_V_STR2FST)cat $< |\
		$(HFST_STRINGS2FST) -j $(HFST_FLAGS) -f openfst-tropical -o $@

# Build an fst with surface form weights that also handles compounds:
.generated/%.surfweights.hfst: .generated/%.surfs.hfst \
                    .generated/word-boundary.hfst
	$(AM_V_HMINIM)$(HFST_MINIMIZE) $(HFST_FLAGS) -i $< -o $@
# Commented out the repetition build step - we only want to promote the compouns
# actually found in the corpus.
#	$(AM_V_HCONCAT)$(HFST_CONCATENATE) $(HFST_FLAGS) word-boundary.hfst $< \
#		| $(HFST_REPEAT) $(HFST_FLAGS) -f 0 -t inf \
#		| $(HFST_CONCATENATE) $< - \
#		| $(HFST_MINIMIZE) -o $@

# Remove word forms covered by the corpus:
.generated/unitweighted_limited.hfst: .generated/generator-%-gt-norm-freq_weighted.hfst \
							$(UW_SPELLER_SRC)
	$(AM_V_FST2FST)$(HFST_FST2FST) --format=foma -i $(UW_SPELLER_SRC) -o $@.tmpfoma.hfst
	$(AM_V_FST2FST)$(HFST_FST2FST) --format=foma -i $< -o $<.tmpfoma.hfst
	$(AM_V_HXFST)$(PRINTF) "read regex \
	~[ @\"$<.tmpfoma.hfst\".u ] \
	.o. @\"$@.tmpfoma.hfst\" \
	; \n\
	save stack $@\n\
	quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY) --format=foma

# Add the unit weight to each unit in compounds, both dynamic and lexical:
#unitweighted.hfst: unitweighted_limited.hfst
.generated/unitweighted.hfst: $(UW_SPELLER_SRC) \
                   .generated/$(UNITWEIGHT)
	$(AM_V_REWEIGHT)$(HFST_FST2FST) --format=openfst-tropical -i $< \
		| $(HFST_REWEIGHT) $(HFST_FLAGS) \
		-e -a $$(cat .generated/$(UNITWEIGHT)) \
		-o $@

# Keep these intermediate targets when building using --debug:
.SECONDARY: spellercorpus.sort.txt \
            spellercorpus.uniq.txt \
            spellercorpus.surfs.hfst \
            spellercorpus.tropical.txt \
            spellercorpus.typecount.txt \
            pellercorpus.wordcount.txt \
            word-boundary.hfst \
            generator-*-gt-norm-freq_weighted.hfst \
            generator-*-gt-norm-unit_weighted.hfst \
            generator-*-gt-norm-norm_weighted.hfst \
            generator-*-gt-norm-tag_weighted.hfst  \
            $(SURFWEIGHTS) \
            $(UNITWEIGHT)

####### Other targets: ###########

# Due to a bug in GNU make (it seems), the target
# 'final_strings.all.%.hfst' will not be built when invoking make
# with -jN, where N > 1, and this causes the whole build to stop, and then on
# the next invocation continue with improperly built prerequisites. To void this
# the following special target will prohibit parallel processes, which ensures
# everything is working as it should. It will make spellers build slower,
# though, but robustness must prevail over speed. At least we can restrict the
# slowdown to this dir only, and the slowdown is only noticable for languages
# building several speller variants.
.NOTPARALLEL:

###################################
####### HFST build rules: #########

####### Easter egg version info: #######
# Easter egg content - depends also on the fst, to
# make sure the easter egg is rebuilt every time the fst is rebuilt:
$(GIELLA_DESKTOP_EASTEREGGS): \
easteregg.%.desktop.txt:
	$(AM_V_GEN)$(GTCORE)/scripts/make-hfstspeller-version-easter-egg.sh \
		$(GTLANG2) \
		$(top_srcdir) \
		$(SPELLERVERSION) \
		"desktop" \
		$* \
		> $@

# Easter egg suggestions:
easteregg.%.desktop.suggtxt: easteregg.%.desktop.txt
	$(AM_V_GEN)sed -e 's/^/nuvviDspeller:/' < $< \
		| sed = \
		| sed 'N;s/\n/	/' \
		| perl -pe 's/(.)\t(.+)/\2\t\1/' \
		> $@

.generated/easteregg.%.desktop.errorth.hfst: $(GENDIR)
	$(AM_V_GEN)echo \
		'n u v v i D s p e l l e r:D i v v u n s p e l l e r +N +Err/Orth' \
		| $(HFST_STRINGS2FST) -S $(HFST_FLAGS) \
		> $@

.generated/easteregg.%.desktop.analyser.hfst: $(GENDIR)
	$(AM_V_GEN)echo \
		'D i v v u n s p e l l e r +N' \
		| $(HFST_STRINGS2FST) -S $(HFST_FLAGS) \
		> $@

# Easter egg string acceptor:
# easteregg.%.desktop.temp.hfst: easteregg.%.desktop.txt
.generated/easteregg.%.desktop.hfst: easteregg.%.desktop.txt $(GENDIR)
	$(AM_V_GEN)$(HFST_STRINGS2FST) $(HFST_FLAGS) -j < $< \
		> $@

# easteregg.%.desktop.hfst: easteregg.%.desktop.temp.hfst \
# 				 easteregg.%.desktop.analyser.hfst \
# 				 easteregg.%.desktop.errorth.hfst
# 	$(AM_V_RGX2FST)printf "\
# 		[ [ @\"$<\".u .x. @\"easteregg.$*.desktop.analyser.hfst\".u ] \
# 		| @\"easteregg.$*.desktop.errorth.hfst\" \
# 		];" \
# 		| $(HFST_REGEXP2FST) -S -E $(HFST_FLAGS) \
# 		| $(HFST_INVERT) $(HFST_FLAGS) \
# 		  -o $@

####### Error model: #######
# Error model building - edit distance based on transducer alphabet:
.generated/editdist.%.regex: editdist.%.txt $(initial_letter_deps) $(GENDIR)
	$(AM_V_GEN)$(GTCORE)/scripts/editdist.py \
		--verbose \
		$(swaps) \
		--epsilon='@0@' \
		--default-weight=$(DEFAULT_WEIGHT) \
		--regex \
		--input=$< \
		--output-file=$@ \
		$(initial_letter_error_model_option)

.generated/editdist.%.hfst: .generated/editdist.%.regex $(GENDIR)
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
	   --format=openfst-tropical \
		-o $@

# Initial string edits, if enabled:
.generated/initial_letters.txt.%.hfst: initial_letters.%.txt $(GENDIR)
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j -p \
		-o $@

.generated/initial_letters.regex.%.hfst: initial_letters.%.regex $(GENDIR)
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
	   --format=openfst-tropical \
		-o $@

.generated/initial_letters.all.%.hfst: $(initial_letter_all_deps) $(GENDIR)
	$(initial_letter_all_build)

# Final string edits, if enabled:
.generated/final_strings.txt.%.hfst: final_strings.%.txt $(GENDIR)
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
	   --format=openfst-tropical \
		-o $@

.generated/final_strings.regex.%.hfst: final_strings.%.regex $(GENDIR)
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
	   --format=openfst-tropical \
		-o $@

.generated/final_strings.all.%.hfst: $(final_strings_all_deps) $(GENDIR)
	$(final_strings_all_build)

# Helper fst:
.generated/anystar.hfst: $(GENDIR)
	$(AM_V_RGX2FST)echo "?*" | $(HFST_REGEXP2FST) -o $@

# In-word list of strings known to be misspelled:
.generated/strings.txt.%.hfst: strings.%.txt .generated/anystar.hfst
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
		| $(HFST_CONCATENATE)   .generated/anystar.hfst - \
		| $(HFST_CONCATENATE) - .generated/anystar.hfst   \
		-o $@

# strings regex file:
# Multiply the strings-regex file with the specified value.
# This makes the total edit distance for the content of the regex file N times
# larger as the edit distance, since the file is multiplied again as part of
# the editStrings build target. The idea is that the regex should contain a
# highly targeted set of frequent spelling errors.
.generated/strings.regex.%.hfst: strings.%.regex .generated/anystar.hfst
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
		| $(HFST_CONCATENATE)   .generated/anystar.hfst - \
		| $(HFST_CONCATENATE) - .generated/anystar.hfst   \
		| $(HFST_REPEAT) -f 1 -t $(STRING_REGEX_EDIT_DISTANCE) \
		-o $@

.generated/strings.all.%.hfst: $(strings_all_deps)
	$(strings_all_build)

# Combine edit distance with string pattern edits, then multiply according to
# the specified editing distance. The strings part is included depending on
# variable setting in Makefile.am.
.generated/editdist.all.%.hfst: $(strings_deps) .generated/editdist.%.hfst
	$(strings_fst_include) \
		| $(HFST_REPEAT) -f 1 -t $(EDIT_DISTANCE) \
		-o $@

# Error model building - list of words known to be misspelled:
.generated/words.%.hfst: $(words_deps) easteregg.%.desktop.suggtxt $(GENDIR)
	$(AM_V_STR2FST)grep -h -v '^#' $^ | grep -v '^$$'   \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
		   --format=openfst-tropical \
		-o $@

# The final error model is assembled here:
errmodel.%.hfst: .generated/words.%.hfst \
				 $(initial_letter_deps) \
				 .generated/editdist.all.%.hfst \
				 $(final_strings_deps)
	$(AM_V_RGX2FST)printf "\
		[ @\".generated/words.$*.hfst\"    \
		| \
		  [ \
		      $(initial_letter_fst_include) \
		      @\".generated/editdist.all.$*.hfst\"  \
		      $(final_strings_fst_include) \
		  ] \
		];" \
		| $(HFST_REGEXP2FST) -S -E $(HFST_FLAGS) \
		| $(HFST_PUSH_WEIGHTS) --push=initial    \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw   \
		  -o $@

####### Alternate error model: #######
# Alternatively, the error model can be constructed as a long list of regular
# expressions, semicolon separated:
errmodel.%.hfst: errmodel.%.regex .generated/easteregg.%.hfst
	$(AM_V_GEN)$(HFST_REGEXP2FST) $(HFSTFLAGS) -S -i $< \
		| $(HFST_DISJUNCT) - .generated/easteregg.$*.hfst \
		| $(HFST_PUSH_WEIGHTS) --push=initial  \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw \
		-o $@

# ... or as an xfscript file:
errmodel.%.hfst: errmodel.%.xfscript .generated/easteregg.%.hfst
	$(AM_V_GEN)$(HFST_REGEXP2FST) $(HFSTFLAGS) -S -i $< \
		| $(HFST_DISJUNCT) - .generated/easteregg.$*.hfst \
		| $(HFST_PUSH_WEIGHTS) --push=initial  \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw \
		-o $@

####### Speller acceptor: #######
# Build the automaton used for the speller
$(GT_SPELLER_ACCEPTOR): \
acceptor.%.hfst: $(GT_SPELLER_HFST) filters/remove-error-strings.hfst \
				 .generated/easteregg.%.desktop.hfst
	$(AM_V_PROJECT)$(HFST_COMPOSE) -1 filters/remove-error-strings.hfst -2 $< -F \
		| $(HFST_PROJECT) $(HFST_FLAGS) \
			$(MORE_VERBOSITY) --project=lower \
		| $(HFST_MINIMIZE_SPELLER)                      \
		| $(HFST_DISJUNCT) $(MORE_VERBOSITY) - .generated/easteregg.$*.desktop.hfst  \
		| $(HFST_PUSH_WEIGHTS) $(MORE_VERBOSITY) --push=initial           \
		| $(HFST_FST2FST) $(MORE_VERBOSITY) $(HFST_FLAGS) -f olw          \
		-o $@

####### *.zhfst file: #######
# Finally build the zhfst file, and make a copy in a subdir named '3', so that
# we can test it without installing it (the '3' dir is a voikko requirement):
$(GT_SPELLING_HFST): index.xml \
					 $(GT_ERRMODELS) \
					 $(GT_SPELLER_ACCEPTOR)
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.xml build/$@/index.xml
	$(AM_V_at)cp $(GT_SPELLER_ACCEPTOR) build/$@/$(GT_SPELLER_ACCEPTOR)
	$(AM_V_at)cp $(GT_ERRMODELS) build/$@/$(GT_ERRMODELS)
	$(AM_V_ZIP)cd build/$@/ && $(ZIP) $(ZIPFLAGS) ../../$@ *
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

####### *-desktop.zhfst file: #######
# To make life easier for CI (and possibly the build flie maintainters later),
# create a *-desktop.zhfst file by hard-linking to *.zhfst:
$(ALL_DESKTOP_ZHFST_FILES): \
%-desktop.zhfst: %.zhfst
	$(AM_V_GEN)ln -f $< $@

#### Build rules: ####

# Alternative based on the raw fst instead of the standard orthography:
.generated/acceptor.%.hfst: \
		$(GT_SPELLER_HFST) \
		.generated/easteregg.%.desktop.hfst \
		$(top_builddir)/src/fst/orthography/raw-to-%.compose.hfst $(GENDIR)
	$(AM_V_GEN)cat $< \
		| $(HFST_COMPOSE) $(HFST_FLAGS) -F \
		  -2 $(top_builddir)/src/fst/orthography/raw-to-$*.compose.hfst \
		| $(HFST_PROJECT) $(HFST_FLAGS) --project=lower \
		| $(HFST_MINIMIZE_SPELLER) $(HFST_FLAGS)        \
		| $(HFST_DISJUNCT) - easteregg.$*.desktop.hfst             \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw          \
		-o $@

# Build rule for acceptors for alternate writing systems:
.generated/acceptor.%.hfst: \
		$(GT_SPELLER_HFST) \
		.generated/easteregg.%.desktop.hfst \
		$(top_builddir)/src/fst/orthography/$(DEFAULT_ORTH)-to-%.compose.hfst
	$(AM_V_GEN)cat $< \
		| $(HFST_COMPOSE) $(HFST_FLAGS) -F \
		  -2 $(top_builddir)/src/fst/orthography/$(DEFAULT_ORTH)-to-$*.compose.hfst \
		| $(HFST_PROJECT) $(HFST_FLAGS) --project=lower \
		| $(HFST_MINIMIZE_SPELLER) $(HFST_FLAGS)        \
		| $(HFST_DISJUNCT) - easteregg.$*.desktop.hfst             \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw          \
		-o $@

# Build rule for zhfst files for alternate writing systems:
$(ALT_ORTH_ZHFST_FILES): \
	$(GTLANG2)-x-%.zhfst: \
		index.%.xml \
		acceptor.%.hfst \
		errmodel.%.hfst
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.$*.xml build/$@/index.xml
	$(AM_V_at)cp acceptor.$*.hfst build/$@/acceptor.default.hfst
	$(AM_V_at)cp errmodel.$*.hfst build/$@/errmodel.default.hfst
	$(AM_V_ZIP)cd build/$@/ && $(ZIP) $(ZIPFLAGS) ../../$@ *
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

# Build rule for 5.0 oxt files for alternate writing systems:
# The more specific pattern match first.
$(GTLANG2)-x-%_LO-voikko-5.0.oxt: $(ALT_ORTH_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		if [ -d "$(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)" ]; then \
			$(MKDIR_P) build/$(LOVOIKKO_VERSION)/ && \
			cd build/$(LOVOIKKO_VERSION) && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)/ $(TARGET_DIR)/ && \
			rm -f voikko/3/*.zhfst && \
			cp ../../$< voikko/3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

# Build rule for 4.x oxt files for alternate writing systems:
$(GTLANG2)-x-%_LO-voikko-4.0-mac.oxt: $(ALT_ORTH_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		orth="$*"; \
		version="4.0-mac"; \
		if [ -d "$(OXT_ROOT_DIR)/$$version" ]; then \
			$(MKDIR_P) build/$$version/ && \
			cd build/$$version && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$$version/ $(TARGET_DIR)/ && \
			rm -f 3/*.zhfst && \
			cp ../../$< 3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

$(GTLANG2)-x-%_LO-voikko-4.0-win.oxt: $(ALT_ORTH_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		orth="$*"; \
		version="4.0-win"; \
		if [ -d "$(OXT_ROOT_DIR)/$$version" ]; then \
			$(MKDIR_P) build/$$version/ && \
			cd build/$$version && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$$version/ $(TARGET_DIR)/ && \
			rm -f 3/*.zhfst && \
			cp ../../$< 3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

#### Build rules: ####

# Build rule for acceptors for alternate writing systems:
$(GT_ALT_WS_SPELLER_ACCEPTORS): \
	.generated/acceptor.%.hfst: \
		$(GT_SPELLER_HFST) .generated/easteregg.%.desktop.hfst \
		$(top_builddir)/src/fst/orthography/$(DEFAULT_WS)-to-%.compose.hfst
	$(AM_V_GEN)cat $< \
		| $(HFST_COMPOSE) $(HFST_FLAGS) -F \
		  -2 $(top_builddir)/src/fst/orthography/$(DEFAULT_WS)-to-$*.compose.hfst \
		| $(HFST_PROJECT) $(HFST_FLAGS) --project=lower \
		| $(HFST_MINIMIZE_SPELLER) $(HFST_FLAGS)        \
		| $(HFST_DISJUNCT) - easteregg.$*.desktop.hfst             \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw          \
		-o $@

# Build rule for zhfst files for alternate writing systems:
$(ALT_WS_ZHFST_FILES): \
	$(GTLANG2)-%.zhfst: \
		index.%.xml \
		.generated/acceptor.%.hfst \
		.generated/errmodel.%.hfst
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.$*.xml build/$@/index.xml
	$(AM_V_at)cp acceptor.$*.hfst build/$@/acceptor.default.hfst
	$(AM_V_at)cp errmodel.$*.hfst build/$@/errmodel.default.hfst
	$(AM_V_ZIP)cd build/$@/ && $(ZIP) $(ZIPFLAGS) ../../$@ *
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

# Build rule for 5.0 oxt files for alternate writing systems:
# The more specific pattern match first.
$(GTLANG2)-%_LO-voikko-5.0.oxt: $(ALT_WS_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		if [ -d "$(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)" ]; then \
			$(MKDIR_P) build/$(LOVOIKKO_VERSION)/ && \
			cd build/$(LOVOIKKO_VERSION) && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)/ $(TARGET_DIR)/ && \
			rm -f voikko/3/*.zhfst && \
			cp ../../$(GTLANG2)-$*.zhfst voikko/3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

# Build rule for 4.x oxt files for alternate writing systems:
$(GTLANG2)-%_LO-voikko-4.0-mac.oxt: $(ALT_WS_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		ws="$*"; \
		version="4.0-mac"; \
		if [ -d "$(OXT_ROOT_DIR)/$$version" ]; then \
			$(MKDIR_P) build/$$version/ && \
			cd build/$$version && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$$version/ $(TARGET_DIR)/ && \
			rm -f 3/*.zhfst && \
			cp ../../$< 3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

$(GTLANG2)-%_LO-voikko-4.0-win.oxt: $(ALT_WS_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		ws="$*"; \
		version="4.0-win"; \
		if [ -d "$(OXT_ROOT_DIR)/$$version" ]; then \
			$(MKDIR_P) build/$$version/ && \
			cd build/$$version && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$$version/ $(TARGET_DIR)/ && \
			rm -f 3/*.zhfst && \
			cp ../../$< 3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

#### Build rules: ####

# Build rule for acceptors for specific areas/countries:
.generated/acceptor.%.hfst: \
		$(GT_SPELLER_HFST) .generated/easteregg.%.desktop.hfst \
		$(top_builddir)/src/fst/filters/remove-all_areas_but_%-strings.hfst
	$(AM_V_GEN)cat $< \
		| $(HFST_COMPOSE) $(HFST_FLAGS) -F \
		  -1 $(top_builddir)/src/fst/filters/remove-all_areas_but_$*-strings.hfst \
		| $(HFST_PROJECT) $(HFST_FLAGS) --project=lower \
		| $(HFST_MINIMIZE_SPELLER) $(HFST_FLAGS)        \
		| $(HFST_DISJUNCT) - .generated/easteregg.$*.desktop.hfst             \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw          \
		-o $@

# Build rule for zhfst files for specific areas/countries:
$(AREA_ZHFST_FILES): \
	$(GTLANG2)_%.zhfst: \
		index.%.xml \
		.generated/acceptor.%.hfst \
		.generated/errmodel.%.hfst
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.$*.xml build/$@/index.xml
	$(AM_V_at)cp .generated/acceptor.$*.hfst build/$@/acceptor.default.hfst
	$(AM_V_at)cp .generated/errmodel.$*.hfst build/$@/errmodel.default.hfst
	$(AM_V_ZIP)cd build/$@/ && $(ZIP) $(ZIPFLAGS) ../../$@ *
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

# Build rule for 5.0 oxt files for specific areas/countries:
# The more specific pattern match first.
$(GTLANG2)_%_LO-voikko-5.0.oxt: $(AREA_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		if [ -d "$(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)" ]; then \
			$(MKDIR_P) build/$(LOVOIKKO_VERSION)/ && \
			cd build/$(LOVOIKKO_VERSION) && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$(LOVOIKKO_VERSION)/ $(TARGET_DIR)/ && \
			cp ../../$(GTLANG2)_$*.zhfst voikko/3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

# Build rule for 4.x oxt files for specific areas/countries:
$(GTLANG2)_%.oxt: $(AREA_ZHFST_FILES)
	$(AM_V_GEN)rm -f $@; \
		area="$$(echo $* | cut -d'_' -f1)"; \
		version="$$(echo $* | cut -d'_' -f2 | sed 's/LO-voikko-//')"; \
		if [ -d "$(OXT_ROOT_DIR)/$$version" ]; then \
			$(MKDIR_P) build/$$version/ && \
			cd build/$$version && \
			$(GET_LIBS_COMMAND) \
					 $(OXT_ROOT_DIR)/$$version/ $(TARGET_DIR)/ && \
			cp ../../$(GTLANG2)_$$area.zhfst 3/ && \
			$(ZIP) -r $(VERBOSITY) $(ZIPFLAGS) ../../$@ * ; \
		else \
			echo "  SKIP     $@: Not yet supported." ; \
		fi

####### Other targets: ###########

# vim: set ft=automake:

#### 1. Copy base fst from parent dir:
.generated/$(MOB_UW_SPELLER_SRC): .generated/generator-fstspeller-gt-norm.hfst
	$(AM_V_FST2FST)$(HFST_FST2FST) $(HFST_FLAGS) -f openfst-tropical $< -o $@

#### 2. Add corpus-based frequency weights (all non-hits will disappear from
####    the fst):
.generated/generator-mobilespeller-gt-norm-freq_weighted.hfst: \
				 .generated/generator-mobilespeller-gt-norm-base.hfst \
				 $(MOB_SURFWEIGHTS)
	$(AM_V_COMPOSE)$(HFST_COMPOSE) $(HFST_FLAGS) -F \
			$< $(MOB_SURFWEIGHTS) \
		-o $@

#### 3. Add a default unit weight to anything not covered by the corpus
####    by combining (unioning) the unitweighted.hfst (which is the full
####    lexical fst) with the frequency/corpus-based fst - use priority
####    union to avoid duplication of paths and thus make a mutch smaller
####    (and hence faster) fst:
####
#### Future plan: replace standard union | with priority union .P., when it
#### works properly for weighted fst's.
.generated/generator-mobilespeller-gt-norm-unit_weighted.hfst: \
				 .generated/generator-mobilespeller-gt-norm-freq_weighted.hfst \
				 .generated/mob_unitweighted.hfst
	$(AM_V_HXFST)$(PRINTF) "\
	set encode-weights ON \n\
	read regex \
		@\"$<\" \
	|   @\".generated/mob_unitweighted.hfst\"  \
	; \n\
	save stack $@\n\
	quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY)

#### 4. Add tag-based weights, for adjusting weights according to morphology
####    and other tag-based penalties like words that should not be suggested:
.generated/generator-mobilespeller-gt-norm-tag_weighted.hfst: .generated/$(mob_tag_weighted_dep)  \
				 	 $(srcdir)/weights/$(MOB_TAGWEIGHTS)
	$(AM_V_REWEIGHT)$(HFST_REWEIGHT) $(MORE_VERBOSITY) $(HFST_FLAGS) \
			-T $(srcdir)/weights/$(MOB_TAGWEIGHTS) --arcs-only -i $< \
		-o $@

#### 5. Finally, remove the surface word boundary symbol and do other
####    general cleanup:
.generated/generator-mobilespeller-gt-norm.tmp.hfst: \
			.generated/generator-mobilespeller-gt-norm-tag_weighted.hfst \
			filters/remove-word-boundary.hfst \
			filters/remove-usage-tags.hfst
	$(AM_V_HXFST)$(PRINTF) "\
	set encode-weights ON \n\
	read regex \
	    @\"filters/remove-usage-tags.hfst\" \
	.o. @\"$<\" \
	.o. @\"filters/remove-word-boundary.hfst\"  \
	; \n\
	save stack $@\n\
	quit\n" | $(HFST_XFST) -p $(MORE_VERBOSITY)

# Invert the final fst, to enable symmetric yaml tests and easy manual testing:
.generated/analyser-mobilespeller-gt-norm.hfst: .generated/generator-mobilespeller-gt-norm.hfst
	$(AM_V_INVERT)$(HFST_INVERT) $(MORE_VERBOSITY) $(HFST_FLAGS) -i $< -o $@

    %.hfst: weights/%.att
	$(AM_V_GEN)$(HFST_TXT2FST) $(HFST_FLAGS) -f openfst-tropical $< -o $@

# sort the clean corpus:
%.sort.txt: weights/%.clean.txt
	$(AM_V_GEN)sort < $< > $@

# token count:
%.wordcount.txt: %.sort.txt
	$(AM_V_GEN)wc -l < $< > $@

# Unique the sorted, clean corpus:
mob_%.uniq.txt: %.sort.txt
	$(AM_V_GEN)uniq -c < $< | sort -nr $(mob_corpus_size_limit_command) > $@

# type count:
mob_%.typecount.txt: mob_%.uniq.txt
	$(AM_V_GEN)wc -l < $< > $@

# calculate unit weight, smoothed using ALPHA:
#%.unitweight.txt: %.wordcount.txt %.typecount.txt
#	$(AM_V_GEN)paste $^ |\
#		sed -e "s/^/scale=5; -l($(ALPHA)\/(/" \
#		    -e "s/	/ + ($(ALPHA) */" -e "s/$$/)))/" \
#		| $(BC) -l > $@

#%.unitweight.txt: %.tropical.txt
#	$(AM_V_GEN)echo "$$(cut -f2 < $^ | sort -nru | head -n1) + $(ALPHA)" \
#		| $(BC) -l > $@
#
# add tropical weights to the corpus:
mob_%.tropical.txt: mob_%.uniq.txt %.wordcount.txt mob_%.typecount.txt
	$(AM_V_GEN)cat $< |\
		$(GAWK) -v CS="$$(cat $*.wordcount.txt)" \
				-v DS="$$(cat mob_$*.typecount.txt)" \
				-v ALPHA=$(ALPHA)                \
				-f $(GTCORE)/scripts/uniq_count2tropical_weight.awk \
				> $@

# build an fst of surface forms with tropical weights for each word form:
.generated/mob_%.surfs.hfst: mob_%.tropical.txt $(GENDIR)
	$(AM_V_STR2FST)cat $< |\
		$(HFST_STRINGS2FST) -j $(HFST_FLAGS) -f openfst-tropical -o $@

# Build an fst with surface form weights that also handles compounds:
.generated/mob_%.surfweights.hfst: .generated/mob_%.surfs.hfst \
                    .generated/word-boundary.hfst
	$(AM_V_HCONCAT)$(HFST_CONCATENATE) $(HFST_FLAGS) .generated/word-boundary.hfst $< \
		| $(HFST_REPEAT) $(HFST_FLAGS) -f 0 -t inf \
		| $(HFST_CONCATENATE) $< - \
		| $(HFST_MINIMIZE) -o $@

# Add the unit weight to each unit in compounds, both dynamic and lexical:
.generated/mob_unitweighted.hfst: $(UW_SPELLER_SRC) \
                   $(MOB_UNITWEIGHT)         \
                   $(srcdir)/weights/word-boundary.txt
	$(AM_V_REWEIGHT)$(HFST_REWEIGHT) $(HFST_FLAGS) \
		-e -a $$(cat $(MOB_UNITWEIGHT)) $< \
		-o $@

# Keep these intermediate targets when building using --debug:
.SECONDARY: spellercorpus.sort.txt \
            spellercorpus.uniq.txt \
            spellercorpus.surfs.hfst \
            spellercorpus.tropical.txt \
            spellercorpus.typecount.txt \
            spellercorpus.wordcount.txt \
            word-boundary.hfst \
            generator-fstspeller-gt-norm-freq_weighted.hfst \
            generator-fstspeller-gt-norm-unit_weighted.hfst \
            generator-fstspeller-gt-norm-norm_weighted.hfst \
            generator-fstspeller-gt-norm-tag_weighted.hfst  \
            $(MOB_SURFWEIGHTS) \
            $(MOB_UNITWEIGHT)

####### Other targets: ###########

# Due to a bug in GNU make (it seems), the target
# 'final_strings.all.%.hfst' will not be built when invoking make
# with -jN, where N > 1, and this causes the whole build to stop, and then on
# the next invocation continue with improperly built prerequisites. To void this
# the following special target will prohibit parallel processes, which ensures
# everything is working as it should. It will make spellers build slower,
# though, but robustness must prevail over speed. At least we can restrict the
# slowdown to this dir only, and the slowdown is only noticable for languages
# building several speller variants.
.NOTPARALLEL:

###################################
####### HFST build rules: #########

####### Easter egg version info: #######
# Easter egg content - depends also on the fst, to
# make sure the easter egg is rebuilt every time the fst is rebuilt:
$(GIELLA_MOBILE_EASTEREGGS): \
easteregg.%.mobile.txt: $(MOB_GT_SPELLER_HFST)
	$(AM_V_GEN)$(GTCORE)/scripts/make-hfstspeller-version-easter-egg.sh \
		$(GTLANG2) \
		$(top_srcdir) \
		$(SPELLERVERSION) \
		"mobile" \
		$* \
		> $@

# Easter egg suggestions:
easteregg.%.mobile.suggtxt: easteregg.%.mobile.txt
	$(AM_V_GEN)sed -e 's/^/nuvviDspeller:/' < $< \
		| sed = \
		| sed 'N;s/\n/	/' \
		| perl -pe 's/(.)\t(.+)/\2\t\1/' \
		> $@

# Easter egg string acceptor:
.generated/easteregg.%.mobile.hfst: easteregg.%.mobile.txt $(GENDIR)
	$(AM_V_GEN)$(HFST_STRINGS2FST) $(HFST_FLAGS) -j < $< \
		| $(HFST_PROJECT) $(HFST_FLAGS) --project=lower > $@

####### Error model: #######
# Error model building - edit distance based on transducer alphabet:
.generated/editdist.%.mobile.regex: editdist.%.txt $(mob_initial_letter_deps) $(GENDIR)
	$(AM_V_GEN)$(GTCORE)/scripts/editdist.py \
		--verbose \
		$(mob_swaps) \
		--epsilon='@0@' \
		--default-weight=$(DEFAULT_WEIGHT) \
		--regex \
		--input=$< \
		--output-file=$@ \
		$(mob_initial_letter_error_model_option)

.generated/predict.%.regex: editdist.%.txt $(GENDIR)
	$(AM_V_GEN)$(GTCORE)/scripts/predict.py \
		--verbose \
		--epsilon='@0@' \
		--default-weight=$(DEFAULT_WEIGHT) \
		--regex \
		--input=$< \
		--output=$@

# Initial string edits, if enabled:
.generated/initial_letters.txt.%.mobile.hfst: initial_letters.%.txt $(GENDIR)
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j -p \
		-o $@

.generated/initial_letters.regex.%.mobile.hfst: initial_letters.%.regex $(GENDIR)
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
	   --format=openfst-tropical \
		-o $@

#initial_letters.all.%.hfst: $(mob_initial_letter_all_deps)
#	$(mob_initial_letter_all_build)

# Final string edits, if enabled:
.generated/final_strings.txt.%.mobile.hfst: final_strings.%.txt $(GENDIR)
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
	   --format=openfst-tropical \
		-o $@

.generated/final_strings.regex.%.mobile.hfst: final_strings.%.regex $(GENDIR)
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
	   --format=openfst-tropical \
		-o $@

.generated/final_strings.all.%.hfst: $(mob_final_strings_all_deps) $(GENDIR)
	$(mob_final_strings_all_build)

# In-word list of strings known to be misspelled, fall back for mobile fst's:
# if there is no mobile-specific txt file, it will fall back to the default error
# model file. If there IS a mobile specific txt file, the default rule will apply
# due to pattern matching rules.
.generated/strings.txt.%.mobile.hfst: strings.%.txt .generated/anystar.hfst
	$(AM_V_STR2FST)grep -v '^#' $< | grep -v '^$$' | cut -f1-2 \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
		| $(HFST_CONCATENATE)   .generated/anystar.hfst - \
		| $(HFST_CONCATENATE) - .generated/anystar.hfst   \
		-o $@

# strings regex file:
# Multiply the strings-regex file with the specified value.
# This makes the total edit distance for the content of the regex file N times
# larger as the edit distance, since the file is multiplied again as part of
# the editStrings build target. The idea is that the regex should contain a
# highly targeted set of frequent spelling errors.
.generated/strings.regex.%.mobile.hfst: strings.%.regex .generated/anystar.hfst
	$(AM_V_RGX2FST)$(HFST_REGEXP2FST) -S $(HFST_FLAGS) -i $<\
		| $(HFST_CONCATENATE)   .generated/anystar.hfst - \
		| $(HFST_CONCATENATE) - .generated/anystar.hfst   \
		| $(HFST_REPEAT) -f 1 -t $(STRING_REGEX_EDIT_DISTANCE) \
		-o $@

.generated/strings.all.%.mobile.hfst: $(mob_strings_all_deps)
	$(mob_strings_all_build)

# Combine edit distance with string pattern edits, then multiply according to
# the specified editing distance. The strings part is included depending on
# variable setting in Makefile.am.
# Then combine it with keyboard layout error model:
.generated/editdist.all.%.hfst.tmp: $(strings_deps) .generated/editdist.%.hfst
	$(strings_fst_include) > $@

.generated/editdist.all.%.hfst: .generated/editdist.all.%.hfst.tmp
	$(AM_V_CP)cp -f $< $@
#.generated/editdist.all.%.hfst: .generated/editdist.all.%.hfst.tmp .generated/keyboardlayout.hfst
#	$(AM_V_UNION)$(HFST_DISJUNCT) $^ \
#		| $(HFST_REPEAT) -f 1 -t $(EDIT_DISTANCE) \
#		-o $@

# Error model building - list of words known to be misspelled, mobile version:
.generated/words.%.mobile.hfst: $(mob_words_deps) easteregg.%.mobile.suggtxt $(GENDIR)
	$(AM_V_STR2FST)grep -h -v '^#' $^ | grep -v '^$$'   \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
		   --format=openfst-tropical \
		-o $@

# Error model building - list of words known to be misspelled, mobile
# fallback version, using the default words.txt file as input instead:
.generated/words.%.mobile.hfst: $(words_deps) easteregg.%.mobile.suggtxt $(GENDIR)
	$(AM_V_STR2FST)grep -h -v '^#' $^ | grep -v '^$$'   \
		| $(HFST_STRINGS2FST) $(HFST_FLAGS) -j \
		-o $@

.generated/keyboardlayout.hfst: keyboardlayout.att .generated/anystar.hfst
	$(AM_V_TXT2FST)$(HFST_TXT2FST) $< \
		| $(HFST_CONCATENATE)   .generated/anystar.hfst - \
		| $(HFST_CONCATENATE) - .generated/anystar.hfst   \
		> $@

# The final error model is assembled here:
.generated/errmodel.%.hfst: .generated/words.%.hfst \
				 $(mob_initial_letter_deps) \
				 .generated/editdist.all.%.hfst \
				 $(mob_final_strings_deps)
	$(AM_V_RGX2FST)printf "\
		[ @\".generated/words.$*.hfst\"    \
		| \
		  [ \
		      $(mob_initial_letter_fst_include) \
		      @\".generated/editdist.all.$*.hfst\"  \
		      $(mob_final_strings_fst_include) \
		  ] \
		];" \
		| $(HFST_REGEXP2FST) -S -E $(HFST_FLAGS) \
		| $(HFST_PUSH_WEIGHTS) --push=initial    \
		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw   \
		  -o $@

# with wordform prediction
.generated/errmodel.%.predict.hfst: .generated/predict.%.hfst
	hfst-fst2fst -f olw -v -i $< -o $@

######## Alternate error model: #######
#errmodel.%.hfst: errmodel.%.regex easteregg.%.hfst
#	$(AM_V_GEN)$(HFST_REGEXP2FST) $(HFSTFLAGS) -S -i $< \
#		| $(HFST_DISJUNCT) - easteregg.$*.hfst \
#		| $(HFST_PUSH_WEIGHTS) --push=initial  \
#		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw \
#		-o $@
#
#errmodel.%.hfst: errmodel.%.xfscript easteregg.%.hfst
#	$(AM_V_GEN)$(HFST_REGEXP2FST) $(HFSTFLAGS) -S -i $< \
#		| $(HFST_DISJUNCT) - easteregg.$*.hfst \
#		| $(HFST_PUSH_WEIGHTS) --push=initial  \
#		| $(HFST_FST2FST) $(HFST_FLAGS) -f olw \
#		-o $@
#
####### Speller acceptor: #######
# Build the automaton used for the speller
$(MOB_GT_SPELLER_ACCEPTOR): \
acceptor.%.hfst: $(MOB_GT_SPELLER_HFST) .generated/easteregg.%.hfst
	$(AM_V_PROJECT)$(HFST_PROJECT) $(HFST_FLAGS) \
			$(MORE_VERBOSITY) --project=lower < $< \
		| $(HFST_MINIMIZE_SPELLER)                      \
		| $(HFST_DISJUNCT) $(MORE_VERBOSITY) - .generated/easteregg.$*.hfst          \
		| $(HFST_PUSH_WEIGHTS) $(MORE_VERBOSITY) --push=initial           \
		| $(HFST_FST2FST) $(MORE_VERBOSITY) $(HFST_FLAGS) -f olw          \
		-o $@

$(MOB_GT_PREDICT_ACCEPTOR): $(MOB_GT_SPELLER_ACCEPTOR)
	$(HFST_FST2FST) -f olw -i $< -o $@

####### *.zhfst file: #######
# Finally build the zhfst file, and make a copy in a subdir named '3', so that
# we can test it without installing it (the '3' dir is a voikko requirement):
$(MOB_GIELLA_SPELLING_HFST): index.mobile.xml \
					 $(MOB_GIELLA_ERRMODELS) \
					 $(MOB_GT_SPELLER_ACCEPTOR)
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.mobile.xml build/$@/index.xml
	$(AM_V_at)cp $(MOB_GT_SPELLER_ACCEPTOR) build/$@/acceptor.default.hfst
	$(AM_V_at)cp $(MOB_GIELLA_ERRMODELS) build/$@/errmodel.default.hfst
	$(AM_V_ZIP)cd build/$@/ && $(ZHFST_COMPRESSION)
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

#index.predict.xml: index.mobile.xml
#	sed -e "s@$(MOB_GIELLA_ERRMODELS)@$(MOB_GIELLA_PREDICTMODELS)@g" \
#		-e "s@$(MOB_GT_SPELLER_ACCEPTOR)@$(MOB_GT_PREDICT_ACCEPTOR)@" \
#		< $< > $@
index.predict.xml: index.mobile.xml
	cp -v $< $@

$(MOB_GIELLA_PREDICT_HFST): index.predict.xml \
					 $(MOB_GIELLA_PREDICTMODELS) \
					 $(MOB_GT_PREDICT_ACCEPTOR)
	$(AM_V_at)rm -f $@
	$(AM_V_at)$(MKDIR_P) build/$@
	$(AM_V_at)rm -f build/$@/*
	$(AM_V_at)cp index.predict.xml build/$@/index.xml
	$(AM_V_at)cp $(MOB_GT_PREDICT_ACCEPTOR) build/$@/acceptor.default.hfst
	$(AM_V_at)cp $(MOB_GIELLA_PREDICTMODELS) build/$@/errmodel.default.hfst
	$(AM_V_ZIP)cd build/$@/ && $(ZHFST_COMPRESSION)
	$(AM_V_at)$(MKDIR_P) 3
	$(AM_V_at)cp -f $@ 3/

####### Other targets: ###########

# Keep these intermediate targets when building using --debug:
.SECONDARY: editdist.all.default.hfst \
            strings.default.hfst     \
            editdist.default.hfst    \
            editdist.default.regex    \
            words.default.hfst \
            initial_letters.list.default.hfst \
            initial_letters.regex.default.hfst \
            initial_letters.all.default.hfst \
            final_strings.default.hfst

# vim: set ft=automake:

# We need a special target for regexes that must be compiled in the selected fst
# format while in the same dir as regexes that should be compiled using the
# openfst format. These are typically for spellers and other weighted utilities:
$(SELECTED_FORMAT_REGEX_TARGETS): \
%.hfst: %.regex
	$(AM_V_RGX2FST)"$(HFST_REGEXP2FST)" $(HFST_FLAGS) $(HFST_FORMAT) \
		$(HFST_REGEXP2FST_FLAGS) $(MORE_VERBOSITY) -S $< -o $@

# We need a special target for regexes that must be compiled in the openfst
# format while in the same dir as regexes that can be compiled using the chosen
# format. These are typically for spellers and other weighted utilities:
$(OFST_REGEX_TARGETS): \
%.hfst: %.regex
	$(AM_V_RGX2FST)"$(HFST_REGEXP2FST)" $(HFST_FLAGS) \
	   --format=openfst-tropical \
		$(HFST_REGEXP2FST_FLAGS) $(MORE_VERBOSITY) -S -i $< -o $@

# By default, and for Xerox compatibility, all regexes are semicolon separated
# (that is the '-S' flag):
.regex.hfst:
	$(AM_V_RGX2FST)"$(HFST_REGEXP2FST)" $(HFST_FLAGS) $(HFST_FORMAT) \
		$(HFST_REGEXP2FST_FLAGS) $(MORE_VERBOSITY) -S $< -o $@

####### Xerox build rules: #######

# xfst needs a script to read regex file
.regex.xfst:
	$(AM_V_XFST)$(PRINTF) "read regex @re\"$<\";\nsave stack $@\nquit\n" \
		| "$(XFST)" $(XFSTFLAGS) $(VERBOSITY)

####### Foma build rules: #######

# foma needs a script to read regex file
.regex.foma:
	$(AM_V_FOMA)$(PRINTF) "read regex @re\"$<\";\nsave stack $@\nquit\n" \
		| "$(FOMA)" $(FOMAFLAGS) $(VERBOSITY)

# vim: set ft=automake:

####### HFST build rules: ########
.generated/%.hfst: %.xfscript $(GENDIR)
	$(AM_V_HXFST)printf "\n\nsave stack $@\nquit\n" | cat $< - \
		| "$(HFST_XFST)" -p $(MORE_VERBOSITY) $(HFST_FORMAT)

####### Xerox build rules: #######
.generated/%.xfst: %.xfscript $(GENDIR)
	$(AM_V_XFST)"$(XFST)" $(VERBOSITY) -l $< -e "save stack $@" -stop

####### Foma build rules: #######
.generated/%.foma: %.xfscript $(GENDIR)
	$(AM_V_FOMA)"$(FOMA)" $(VERBOSITY) -l $< -e "save stack $@" -s

# Pattern variables to choose tools depending on which toolset we build for:
%.hfst : XFST_TOOL      = $(HFST_XFST) -p $(MORE_VERBOSITY) $(HFST_FORMAT)
%.xfst : XFST_TOOL      = $(XFST) $(VERBOSITY)
%.foma : XFST_TOOL      = $(FOMA) $(VERBOSITY)
# following is just more verbose error message when some rule tries to invoke
# xfst-tool for %.hfstol pattern which won't work, solve it by static pattern
# that bloxks the hfstol like:
# foobar.hfst \
# foobar.xfst \
# foobar.foma: \
# foobar.%: foobar.tmp.%
%.hfstol : XFST_TOOL    = false THIS IS A BUG IN MAKEFILE see xfscript-include.am

%.hfst : AM_V_XFST_TOOL = $(AM_V_HXFST)
%.xfst : AM_V_XFST_TOOL = $(AM_V_XFST)
%.foma : AM_V_XFST_TOOL = $(AM_V_FOMA)

%.hfst : INVERT_HFST = invert net\n
%.xfst : INVERT_XFST = invert net\n
%.foma : INVERT_FOMA = invert net\n

# vim: set ft=automake:

$(GENDIR):
	$(AM_V_at)$(MKDIR_P) `dirname $@`
	$(AM_V_GEN)touch $@

# XXX while split between temporary and final targets isn't cleaned up
%.hfst: .generated/%.hfst
	$(AM_V_CP)cp $< $@

%.xfst: .generated/%.xfst
	$(AM_V_CP)cp $< $@

%.foma: .generated/%.foma
	$(AM_V_CP)cp $< $@

# maybe...
clean-local: clean-local-gendir
.PHONY: clean-local-gendir
clean-local-gendir:
	@rm -rf .generated

# vim: set ft=automake:

# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
